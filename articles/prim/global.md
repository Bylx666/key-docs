# 全局函数和类型

## `log`

不限参数, 打印一个值的字符串`Str`格式. 

如果你只需要字符串而不要打印, 使用<jmp to="/prim/str#from">`Str::from`</jmp>. 

## `debug`

该函数使用`Rust`的格式化方法, 将值的类型和内容详细打印出来. 

不限参数, 无返回值. 

该函数的行为不作为Key语言标准, 不要依赖`debug`的实际行为去实现自己的逻辑. 

## `run_ks`

在当前作用域解析一个字符串`Str`或数组`Buf`并运行, 相当于`eval`.

需要注意的是, 该函数对于字符串的行为, 和直接在当前作用域写的代码几乎无异, 就连`let`和`mod`也会在当前作用域生效. 

使用`run_ks`和直接写的代码, 不同的地方在于`run_ks`过程中出错会提示报错的`run_ks`表达式的位置. 

另外, 你可以考虑使用<jmp to="/prim/func#new">`Func::new`</jmp>来创建一个函数, 并调用其<jmp to="/prim/func#clone_top">`clone_top`</jmp>方法来创建一个作用域在目前模块顶端的函数, 或许可以减少代码的安全问题. 

## `version`

返回`Uint`, 作为Key解释器的版本号, 是十进制`100000`开头的整数.

## `distribution`

发行者, 返回字符串`"Subkey"`, 代表Key解释器的发行者. 对于魔改版本的Key解释器, 该函数的返回值或有各种不同. 

## `swap`

传入两个值, 将其调换位置. 

## `take`

传入一个值, 将其返回, 并把原来的值变为`uninit`. 

该函数很好的维持了"赋值皆复制"的理念下, Key语言的性能. 

## `fmt`

格式化一个字符串, 目前暂无格式化参数. 

传入一个字符串, 并将其中的`{}`替换为后续参数, 返回字符串`Str`. 

无参数则返回空字符串. 

```ks
log(fmt("原神, {}", "启动!"));
// 原神, 启动!
```

如果需要通过`fmt`打印大括号`{}`, 则: 

```ks
log(fmt("大括号yes{}", "{}"));
// 大括号yes{}
```

## `Planet`类

行星, 作为Key语言异步行为的基础. 详见<jmp to="/guide/async">异步操作</jmp>.

## `Sym`类

只有一个静态方法`iter_end`, 作为迭代器结束的标识. 
