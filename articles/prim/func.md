# 函数`Func`

## 属性

### `name`

返回一个字符串, 代表该函数的名字. 对于原生函数会直接得到`@native`, 对于各种不是由`let a()`创建的函数会得到`unnamed`. 

### `type`

返回一个字符串: 

|字符串|含义|
|`local`|在ks文件中定义的函数|
|`native`|原生模块中的函数|
|`extern`|(非标准)通过`extern`语句得到的函数|

### `raw`

返回一个`Uint`, 代表了一个函数的指针(仅用于比较). 用途在于使用[`clone_here`](#clone_here)得到的函数可以使用`raw`属性判断是否和原函数相同. 

## 实例方法

### `call`

需要传入一个值作为`self`, 之后的参数才会作为调用函数的参数. 

### `call_here`

需要传入一个值作为`self`, 之后的参数作为调用函数的参数, 并在当前作用域调用(使函数的上下文直接变成当前作用域). 

### `clone_here`

无参数, 将自己复制为一个作用域为当前作用域的函数并返回. 

### `clone_top`

无参数, 将自己复制为一个作用域为当前模块的顶级作用域的函数并返回. 

### `unzip`

无参数, 无视函数的参数, 直接将自己的语句解压到当前作用域并运行. 

函数中的`return`会作为`unzip`本身的返回值, 如果不在循环内, `break`和`continue`将正常报错. 

非常适合`prelude`行为. 详见<jmp to="/guide/func#宏-unzip">宏-`unzip`</jmp>.

## 静态方法

### `new`

传入一个字符串作为解析的函数体`body`, 之后可以传入`n`个字符串作为该函数的参数名. 

在当前作用域创建一个参数为这`n`个字符串, 函数体为`body`的新函数. 

```ks
// 该作用域有一个c变量
let c = 20;
// 创建一个函数, 函数内容为返回a+b+c
let f = Func::new(":a+b+c", "a", "b");
log(f(2,4)); // 26
```

如果你不希望函数访问到你现在的作用域, 就配合`clone_top`使用: 

```ks
{
  // inner是小作用域里的变量
  let inner = 20;
  // 创建一个返回inner的函数
  // 并使用clone_top使其在顶级作用域
  let f = Func::new(":inner").clone_top();
  f(); // > 无法找到变量 'inner'
}
```
