# 哈希表`Obj`

只是个哈希表. 任何遍历方法均不保证插入顺序和迭代顺序. 

值得注意的是, 虽然`Obj`是对象的意思, 但在Key中请叫它`哈希表`而不是对象. 因为`对象`的含义在多个编程语言中较为多样, 不容易轻易区分; 而Key语言中尽量避免使用`对象`这个名词. 

换句话说, 类的实例应当叫作`原生类实例`或`本地类实例`而不是对象, 哈希表`Obj`应当叫作`哈希表`. 这不单单是为了减少混淆, 还是为了让用户在使用`Obj`时能想起来它本身作为哈希表的特性, 而不是`对象`. 

## 属性

`Obj`可以使用属性的写法来读写其内容. 读取时若无此数据则返回`uninit`, 写入时若无此数据则自动插入此数据. 

`Obj`也可以使用一个字符串索引, 读写行为同上. 

需要注意的是, `obj`作为迭代器时, 默认使用[`obj.keys()`](#keys)只迭代键名. 

## 实例方法

### `get`

传入一个字符串, 返回哈希表中该字符串作为键名的值. 若没有这个键名则返回`uninit`. 

### `has`

传入一个字符串作为键名, 返回哈希表是否存在这个键`Bool`. 

### `remove`

传入一个字符串作为键名, 删除哈希表中的该键, 并返回被删除的值. 若本来就不存在该键名, 则返回`uninit`. 

### `for_each`

传入一个函数, 接受被迭代的键对作为参数, 该函数无需返回值. `for_each`无返回值. 

迭代器不保证顺序. 

```ks
obj.for_each(|key:Str, v|{
  ...
})
```

### `keys`

无参数, 返回一个迭代器, 可迭代哈希表的键名`Str`. 迭代器不保证顺序. 

### `values`

无参数, 返回一个迭代器, 可迭代哈希表的值. 迭代器不保证顺序. 

### `entries`

无参数, 返回一个迭代器, 可迭代哈希表的键对(两个元素的列表:`[key:Str, value]`). 

### `len`

无参数, 返回哈希表的元素数量`Uint`. 

### `concat`

传入一个哈希表或本地定义的类实例, 将其合并至自己的哈希表. 重复元素将被新元素覆盖. 无返回值. 

## 静态方法

### `new`

可传入一个整数代表初始内存大小, 返回一个新的空哈希表. (个人认为没啥用的静态方法)

### `concat`

传入任意个哈希表或本地类实例, 将其合并为单个哈希表. 若遇到不是哈希表或本地类实例的值则直接报错. 

如果没有传入参数则返回一个新的空哈希表. 

### `from_list`

将一个储存了键对的列表转换为哈希表. 

第一个参数如果不是`List`则报错. 但`List`内即使不按格式也不会报错, 而是直接忽略. 

```ks
log(Obj::from_list([
  ["test", 233],
  "不是列表", 
  [999, "键名不是字符串"]
]))
// { test: 233 }
```

### `group_by`

传入一个列表, 再传入一个接受当前列表迭代值, 且返回`Str`的函数, 将该列表依据函数返回的`Str`进行分类. 

如果函数没有返回值或没返回字符串, 则直接跳过该元素不予分类. 

返回值是一个只有`List`类型的元素的哈希表. 不过还是那句话, 不保证顺序!

```ks
// 该函数直接返回元素的type属性
// 如果是没有type属性的值, 
// 返回值自然就是uninit而不是Str
// 因此就会被自动跳过
let group_func(v): v.type;

log(Obj::group_by([
  {
    name: "芙卡洛斯"
    type: "神"
  }
  {
    name: "若陀"
    type: "龙"
  }
  "一个不是对象的异类",
  {
    name: "那位来客"
    type: "龙"
  }
], group_func));

/' 打印: {
  神: [
    { name: 芙卡洛斯, type: 神 }
  ], 
  龙: [
    { name: 若陀, type: 龙 }, 
    { name: 那位来客, type: 龙 }
  ] 
}
```
