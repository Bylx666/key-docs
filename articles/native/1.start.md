# 开始

开一个新项目(新建文件夹随便起个名, `cd`进去, `cargo init`)

首先在你的项目中安装`key_native`模块: `cargo add key_native`

然后修改`Cargo.toml`, 在最后添加以下内容(让rust知道你在编译动态链接库, 否则会把你的项目视为可运行程序)

```toml
[lib]
crate-type = ["cdylib"]
```

接着把`main.rs`删掉, 新建一个`lib.rs`(是`cdylib`的要求).

最后在`lib.rs`中这样写: 

```rust
// prelude是预备的意思, 其中为你准备了最常用的部件
// use ..::* 就是使用所有常用部件
use key_native::prelude::*;

// 如果你不懂编译原理的话, 只需要死记这条
// 它相当于#[export_name = "main"]
// 意思是在动态链接库中导出这个函数
// 并命名为main供Key解释器调用
#[no_mangle]
// 该函数就是Key原生模块的主函数, 
// 会在遇到mod xx> m的语句时直接被调用
// NativeModule就是prelude中的一个部件
// 代表的是Key为你创建了一个空模块, 而你会拿到其修改权
// 该模块可以导出函数和类, 之后会说到
fn main(_m:&mut NativeModule) {
  println!("okk");
}
```

至此一切都配置完成了. 运行`cargo build`, 找到`target/debug/`, 里面会有一个`xxlib.dll`的文件, 就是你成功生成的原生模块了. 你可以在vscode中右键此文件, 点复制路径, 然后粘贴到一个`ks`文件中. 

假设你的目录是`d:\code\rust\keytest`, 那么你的`dll`文件应当是`d:\code\rust\keytest\target\debug\keytestlib.dll`. 那么在这个ks文件中:

```
mod d:\code\rust\keytest\target\debug\keytestlib.dll> my_mod;
```

用`key`命令运行这个脚本, 就能看到打印`okk`. 

## 报错

需要注意的是, 希望用户使用`kpanic`替代`panic`, 因为`panic`在你的库中被调用时会在Key解释器中提示`某个线程错误`, 而`kpanic`就能正确打印错误信息和Key中的行号. 

如果我们用了一些库, 当然不可能强求库中所有代码都改用`kpanic`, 
