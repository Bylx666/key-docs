# 开始

开一个新项目(新建文件夹随便起个名, `cd`进去, `cargo init`)

首先在你的项目中安装`key_native`模块: `cargo add key_native`

然后修改`Cargo.toml`, 在最后添加以下内容(让rust知道你在编译动态链接库, 否则会把你的项目视为可运行程序)

```toml
[lib]
crate-type = ["cdylib"]
```

接着把`main.rs`删掉, 新建一个`lib.rs`(是`cdylib`的要求).

最后在`lib.rs`中这样写: 

```rust
// prelude是预备的意思, 其中为你准备了最常用的部件
// use ..::* 就是使用所有常用部件
use key_native::prelude::*;

// 如果你不懂编译原理的话, 只需要死记这条
// 它相当于#[export_name = "main"]
// 意思是在动态链接库中导出这个函数
// 并命名为main供Key解释器调用
#[no_mangle]
// 该函数就是Key原生模块的主函数, 
// 会在遇到mod xx> m的语句时直接被调用
// NativeModule就是prelude中的一个部件
// 代表的是Key为你创建了一个空模块, 而你会拿到其修改权
// 该模块可以导出函数和类, 之后会说到
fn main(_m:&mut NativeModule) {
  println!("okk");
}
```

至此一切都配置完成了. 运行`cargo build`, 找到`target/debug/`, 里面会有一个`xxlib.dll`的文件, 就是你成功生成的原生模块了. 你可以在vscode中右键此文件, 点复制路径, 然后粘贴到一个`ks`文件中. 

假设你的目录是`d:\code\rust\keytest`, 那么你的`dll`文件应当是`d:\code\rust\keytest\target\debug\keytestlib.dll`. 那么在这个ks文件中:

```ks
mod d:\code\rust\keytest\target\debug\keytestlib.dll> my_mod;
```

用`key`命令运行这个脚本, 就能看到打印`okk`. 

## 报错

使用`key_native`时, 程序会自动使用Key语言的报错(将你的库的报错转达给Key解释器, 让其代为报错). 如果你想更改报错方式, 请使用[`std::panic::set_hook`](https://doc.rust-lang.org/std/panic/fn.set_hook.html). 

## 结语

至此基本环境已经准备完成. 下一篇将会带你导出一个函数供Key使用. 
