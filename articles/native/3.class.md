# 声明和导出类

试着实现一个拥有一个静态函数的原生类: 

```rust
use key_native::prelude::*;

// 使用static和uninit方法创建一个空class
static A:Class = Class::uninit();

#[no_mangle]
fn main(m: &mut NativeModule) {
  // 将这个空的class初始化, 名字为A
  // 注意: 初始化(new)之前不可调用其任何其他方法
  A.new("A");
  // 使用export_cls导出一个类
  // 在导出前后, 对这个类的修改都有效
  // Class只是一个指针, 对其clone没有额外性能开销
  m.export_cls(A.clone());
  // 使用static_method方法创建一个静态方法
  // 该方法和export_fn使用方式一致(且函数可互通)
  // 使用create方法创建该类的实例(2个参数目前填0就好)
  A.static_method("new", |_,_|A.create(0, 0));
}
```

你可以在ks中试着使用`is`运算符判断它是否这个类型: 

```
mod ...> m;
let a = m-:A::new();
log(a is m:A); // true
```

我们把`create`的两个参数改一下, 并试着添加一个方法: 

```rust
use key_native::prelude::*;

// 使用static创建一个空class
static A:Class = Class::uninit();

// 创建一个look函数, 用来"看"实例的内容
// 比起普通的原生函数 多了个可读写的instance
fn look(instance:&mut Instance, _args:Vec<LitrRef>, _cx:Scope)-> Litr {
  // 我们直接将2个值相乘并返回
  Litr::Uint(instance.v * instance.w)
}

#[no_mangle]
fn main(m: &mut NativeModule) {
  A.new("A");
  m.export_cls(A.clone());
  // 把两个值改成233和2
  A.static_method("new", |_,_|A.create(233, 2));
  // 使用method方法为该类添加实例方法
  A.method("look", look);
}
```

ks中`look`一下

```
mod ...> m;
log(m-:A::new().look()); // 466
```



## 结语

你在声明要导出的函数时可以看到`cx:Scope`的参数. 它代表了调用该函数时, 脚本所处的作用域. 下一篇我会讲到`Scope`的使用. 