# 模块化

模块使用`mod`关键字导入和导出. 

导入模块:

```ks
// (>必须紧贴文件路径)
mod 文件路径> 模块名
```

需要注意的是: 即使是同一模块, 重复导入也会重新执行模块内容, 相当于重置模块. 也就是说原则上Key语言并不会对你的模块进行缓存行为, 因此你可以安心的在自己的模块中初始化全局变量.

另外, 无论你在什么地方导入模块(不管多深的作用域), 都会共享给整个模块(也就是作用域内声明模块, 作用域外部也能使用该模块)

目前模块只允许导出函数和类型.

## 函数导入和导出

比如我当前cd在一个test文件夹(`cwd`), 里面有一个`module.ks`(要导入的模块)和一个`main.ks`(我要运行的ks文件)

你需要使用`mod.`语句来导出函数, 使用`-.`表达式来读取模块中的函数.

```ks
// module.ks
const i = 90;
mod.func(): i;
// 也可以写成
mod.func = ||: i;
```

```ks
// main.ks
mod module.ks> my_mod;
let i_from_mod = my_mod-.func(); // 90
```

## 类型导入和导出

Key语言使用`mod`关键词导出和导入class. 使用`mod:`语句导出类(对应函数`mod.`), 使用`-:`表达式使用模块中的类(对应函数的`-.`)

假设我的cwd中有一个`module.ks`(作模块)和一个`main.ks`(运行用):

```ks
// module.ks
mod:MyClass {
  >a, // 使用>前缀表示模块外可直接读写此值(public)
  >new(): MyClass::{a:3}, // public的静态方法
  >.test(): self.a.sqrt() // public的实例方法(取数字的平方)
}
```

```ks
// main.ks
mod module.ks> m; // 导入module.ks文件, 作为模块m
class T = m-:MyClass; // 将T作为m模块的MyClass的别名
let direct = T::{a:4}; // 直接构造该类型
let new = T::new(); // 通过静态方法构造
log(direct.test(), new.test())
```

各个部分的导出的实际意义: 
1. `mod:T`和`class T`的区别在于模块外能否使用该类型来类型检查, 以及能否调用其静态方法
2. `> prop`和`prop`的区别在于模块外能否对此属性直接进行读写, 模块外想创建一个此类型的实例必须保证`1.`的同时,所有值都是public`>`状态
3. `> .method()`和`.method()`的区别在于模块外能否调用该类型的实例的此方法(无关乎`1.`)
4. `> static()`和`static()`的区别是, 在`1.`满足public时, 模块外在持有该类型时能否调用此静态方法

不用去刻意记忆或区分这些概念, 作为初学者需要记忆的只是: 一个类型即使没有导出到模块外, 其实例也可以调用自己类型的方法. 比如:

```ks
// module.ks
class A {
  a,b,
  >.yes() log("看来能行")
}
mod.create_a(): A::{}; // 全部缺省
```

```ks
// main.ks
mod module.ks> m;
m-.create_a().yes() // 打印: 看来能行
```

如果模块外想要构造模块内定义的类, 就必须保证所有的属性都是public:

```ks
// module.ks
mod: A {
  >a,>b
}
```

```ks
// main.ks
mod module.ks> m;
m-:A::{a:0,b:0} // 在模块外构造模块内定义的类型时不可省略任何属性
```

只要一个属性不是public, 模块外就因为无法访问该属性而无法构造该类型. 这个特点想必可以帮你减轻些模块内的属性值的判断压力. 

## 结语

模块化不仅能提升用户代码分类意识, 还能保护私有类型不被非法数值侵入. 这意味着Key对各类框架的支持将属于原生支持, 而非补丁. 

Key语言中原生支持管道操作符哦! 下一章我会说明Key语言支持的运算符和行为.
