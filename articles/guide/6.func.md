# 函数

函数`Func`使用`let f()`来定义, 用`return`(返回)语句来表示函数被调用时得到的值. 

```ks
// 用let f()定义函数
let f() return 50;
// 用f()调用函数
// 打印50
log(f());
```

`return`还能退出循环: 

```ks
let f() {
  let i = 0;
  for! {
    // 在i为3时直接返回
    // 无需break
    if i==3 {
      return i;
    }
    i += 1;
    log(i);
  }
}
// 首先打印出循环过程的1 2 3
// 之后在此打印出f()的值3
log(f());
```

有趣的是, key语言中可以使用`:`代替`return`: 

```ks
let f(): 20;
// 打印20
log(f());
```

`:`不会被解析为运算符, 因此可以在任何可以写语句的地方使用. 

## 参数

定义函数时可以定义其参数`arguments`, 代表着调用这个函数时可以传入的值. 

参数名之间用`,`分隔, 该`,`可省略. 

我们写一个`max`函数来判断传入的`a`和`b`谁更大: 

```ks
// 定义参数a和b
let max(a, b) {
  // 在a>b时返回a
  if a>b: a
  // 否则返回b
  else: b
}
// 传入的a为2
// 传入的b为5.5
// 打印: 5.5
log(max(2, 5.5));
```

有趣的是, 传入参数时你可以留空参数: 

```ks
// 定义参数之间逗号可省略
let f(a b c) log(b);
// 将a和c直接留空
// 函数中a和c都会变成uninit
// 打印: 2
f( , 2, );
```

## 动态类型检查

对于参数定义, 你还可以使用`动态类型检查`. 

使用`变量名: 类型`的参数定义进行动态类型检查. 

```ks
// 要求a是字符串, b是整数
// 分号只是个空语句
let f(a: Str, b: Int);
// 无事发生
f("233", 20);
// 报错: 要求a是Str,
// 但你传入了uninit
f(,)
```

为什么叫动态类型检查? 因为key语言不需要编译成可运行的程序, 而是直接运行你的代码. 

你的参数和类型都是在运行过程中检查的, 所以叫作动态类型检查. 

类型检查非常方便, 可以帮你立刻过滤掉错误的调用, 让你立马找到一些问题的根源. 

## 默认值

你可以在参数后使用`=`来代表一个用户未传参数或传了`uninit`时的替代值. 

```ks
let f(a = 5) log(a);
// 不传参数: 5
f();
// 传uninit: 5
f(,);
// 传实际参数: 20
f(20);
```

你也可以在使用动态类型检查的同时使用默认值: 

```ks
let f(a: Int = 5) log(a);
// 打印: 5
f();
// 报错: 要求Int但传入了Str
f("233");
```

默认值还可以是变量之类的表达式: 

```ks
const MAX = Uint::max();
let f(a = MAX) log(a);
// 打印Uint的最大值
f();
```

该写法也可行: 

```ks
let f(a = Uint::max()) log(a);
f();
```

## 字面量

函数可以直接写为`|参数定义| 函数体`当作一个值使用. 

以下两种写法的效果是相同的:

```ks
let f(): 20;
let f = ||:20;
```

这种写法叫作`函数字面量`. 函数字面量也支持使用动态类型检查和默认参数. 

```ks
// 直接调用一个
// 就地创建的函数
// 错误: 要求Str但传入了Int
(|a:Str|;)(20)
```

有了函数字面量, 你就可以试一试列表的`for_each`方法: 

```ks
let a = [2,4,6];
// 在for_each中创建一个函数
// 打印2 4 6
a.for_each(|n| log(n));
```

## 自定义参数

我想要不定长度的参数怎么做? 

自定义参数的函数使用`let f([args])`或`|[args]|`来定义, `args`是你的参数名. 

当你使用自定义参数时, 你会得到一个名为`args`的列表, 列表中就是传入的实际参数. 

下面的例子中会用到`is`运算符, 用来判断一个值是否为一个类型. 

```ks
let f([args]) {
  // 如果只传了一个参数
  if args.len == 1 {
    // 将第一个参数解构移动出来
    let [arg] < args;
    log(`只有一个参数:{arg}`)
  }

  // 如果传了2个参数
  if args.len == 2 {
    // 将2个参数解构移动出来
    let [arg0, arg1] < args {
      // 判断第一个参数是否字符串
      // 使用'!'运算符取bool的相反值
      if !(arg0 is Str) {
        // 如果不是字符串就打印这句
        log("第一个参数必须是字符串");
        // 直接返回, 不再继续运行
        return;
      }
      // 打印出这两个参数
      log(`有两个参数欸{arg0} {arg1}`);
    }
  }
};

// 只传一个参数试试
// 打印: 只有一个参数:233
f(233);

// 传2个参数试试
// 打印: 有两个参数欸yes 20
f("yes", 20);

// 试试is类型检查
// 打印: 第一个参数必须是字符串
f(99, 0);
```

该示例较长, 但全部都是基础知识, 希望你能多些耐心来理解. 

示例中, `!(arg0 is Str)`的意思是, `arg0`是字符串这件事 的真假 的相反值. 

`!`运算符的用法为: 

```ks
// false
log(!true);
// true
log(!false);
// 假就等于假, 所以是true
log(!true == false);
```

其他方法请参见<jmp to="/prim/func">`Func`方法</jmp>

## 管道操作符

函数自然离不开嵌套. 

看这段: 

```ks
let arg = "一个参数";
let f(s) {
  :"一个" + s // 在传入字符串前加`一个`
}
let a = f(f(arg));
// 一个一个一个参数
log(a);
```

Key语言中使用`|>`符号来解决各种丑陋的嵌套问题. 

使用`|%|`来代入管道前的表达式. 

```ks
let arg = "一个参数";
let f(s) {
  :"一个" + s
}
let a = arg
  |> f( |%| ) // 把arg代入到参数里
  |> f( |%| ) // 把f(arg)的结果再次代入f
log(a) // 一个一个一个参数
```

有趣的是, `|>`右侧并不必要使用`|%|`来代入表达式. 

你甚至可以先存一发表达式, 在其他地方代入:

```ks
a+b |> () // ()是uninit, 意思是不做任何事情
         // 此时|%|中储存了`a+b`的表达式
{
  let a = 2;
  let b = 4;
  log( |%| ) // 代入到这么远的地方, 可以得到6
}
```

## 结语

函数难么? 写起来不难. 真不难么? 一开始阅读别人的函数就开始头疼了. 

事实确实如此, 函数只是一个功能, 一个语句的平台. 只有经验才是真本事. 

下一篇: 

## 参考

任何编程语言中, 函数都是极其复杂的概念. 希望在你大致掌握key语言后再来到这里能有新的收获. 

### 顶级作用域返回

主脚本的顶级作用域使用返回时, 会停止后续语句, 并将`Int`的返回值作为退出码. 

非`Int`返回值会被忽略.

```ks
// 顶级作用域
:20
// error: process didn't exit successfully: `...` (exit code: 20)
```

### 哈希表中的函数

哈希表的属性和调用方法都是`.`, 区分它们的方法是使用圆括号. 

```ks
let o = {f:||log("ok")};
// ok
(o.f)();
```

### 宏-`call_here`

Key语言有个别的脚本都没做过的功能, 就是改变函数作用域. 换句话说, 你的每个函数都可以当作一个宏来使用. 

使用`call_here`:

```ks
let a;
let b;
let initer;
{ // 模拟作用域变化
  let a = 99;
  let b = 32;
  let f() {
    a = 20;
    b = 10;
  }
  initer = f;
}

// 两种情况下的最外层的a,b值
initer(); // a == (), b == ();
initer.call_here(()) // 第一个参数代表函数内的self, 传个uninit就行
                     // a == 20, b == 10
```

改变作用域时如果函数带有默认参数, 由于函数的上下文变化, 默认参数的上下文也会跟着变化(如果你的默认参数写了变量之类的就会跟着变成现在的上下文的该变量)

函数中的参数如果设定了自定义类型, 到了新作用域也会跟随新作用域的同名类型(没有同名类型就报错啦)

### 宏-`unzip`

你可以使用`unzip`方法直接将函数体解压到某处. 函数的参数将被完全忽略. 

试试使用`unzip`来初始化一个作用域. 这种对上下文初始化的行为叫作`prelude`. 

```ks
let inner() {
  class A{};
  let a = 20;
  let b = 40;
}

{
  inner.unzip();
  log(a, b, A::{});
  // 20 40 60
}
```

值得注意的是, `unzip`的函数中的`return`会成为`unzip`方法的返回值. 

`continue`和`break`不会中断`unzip`外的循环, 而是直接报错. 

### outlive

`outlive`的意思是延长生命. 

`outlive`是key语言的生命周期模型, 本质是引用计数. 

考虑这样的情形(函数拿着自己作用域的变量跑到作用域外面去了): 

```ks
let a = [];
for n: 5 {
  a.push(||log(n));
}
// 正常输出0-4
a.for_each(|f|f());
```

和这样的(函数返回了一个拿着自己作用域的值的函数): 

```ks
let a = 5;
let f1() {
  let a = 20;
  :||:a;
}
log(f1()()) // 20
```

可它们是怎么运行的? 为什么函数离开作用域后它持有的变量还活着? 

因为当函数离开作用域时, 函数定义处的作用域的引用计数会提升, 而作用域结束时发现有函数离开自己了, 就不会立刻结束生命, 而是等出家的函数都死去了自己才会跟着死去. 

以下是我对`outlive`的实现

1. 作用域结构需要定义一个原子数字, 将其定义为`outlive`属性, 在我的Rust实现中使用了`AtomicUsize`
2. 你在作用域中创建函数时, 会为此作用域和此作用域以上的所有作用域的`outlive`的数值`+1`.
3. 当函数被复制时(赋值行为等), 为此函数的定义处作用域和定义处作用域以上的所有作用域的`outlive`的数值`+1`. 我的Rust实现为`impl Clone for Function {..clone(&self).. { self.increase_outlive_count() }}`. 函数复制到哪了暂时不需要管. 
4. 当函数丢失时(持有函数的变量被修改成了其他值等), 为此函数定义处作用域和定义处作用域以上的所有作用域`outlive`的数值`-1`. 遍历`-1`的过程中需要判断, 如果作用域已经结束了, 而且outlive被减为0, 就以函数回收的名义将该作用域回收掉. 我的实现是`impl Drop for Function {..drop(&mut self){ self.decrease_outlive_count() }}`
5. 作用域结束时, 对应`2.`, 将作用域所持有的所有函数(包括List, Instance, Obj内的)进行`outlive -1`操作, 和`4.`的行为一致. 之后将作用域的状态设置为已结束, 判断自己身上的outlive是否为0, 如果为0就将自己回收(以作用域正常结束的名义), 否则就不管自己, 等自己体内定义的函数被回收完自动回收自己. 回收后请把作用域指针写为`null`. 
6. `decrease_outlive_count`虽然只是遍历上层作用域把`outlive`值减一, 但由于在回收作用域本身时会额外调用一次`Drop`, 导致再一次运行函数的`decrease_outlive_count`, 因此你必须在该函数开头判断自己的作用域是否已经回收过了(判断作用域指针非零). 

我的Rust的outlive实现在[`key-lang`](https://github.com/Bylx666/key-lang)仓库的`src/runtime/outlive.rs`. 