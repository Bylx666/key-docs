# 异步操作

Key语言使用行星(`Planet`)来将异步函数(需要使用回调函数才能取值)以同步的写法融入到同步代码. Key语言保留`async`和`await`关键字, 但暂时未使用, 取而代之的是`fall`方法, 可以阻塞主线程直到行星的异步任务返回值. 

之所以是`Planet`和`fall`, 是因为`Plan`作为计划, 一开始是对标Javascript中的`Promise`. 但事实上行星和`Promise`使用方式差距甚远. 行星会坠落`Fall`阻塞主线程, 而用户得到坠落的行星中的值, 便可继续前进. 

Key语言的标准库尚不完善, 因此以下示例在标准库完成之前或许咱不可用. 如果你较为熟络`Rust`或`C`系列, 希望你能移步<jmp to="/native/6.planet">使用`Planet`</jmp>进行实际程序的操作和尝试. 

本文章目前仅作为参考, 并作为对Key语言标准的补充. 

## 回到`await`之前

我们假设有一个函数`set_timeout`, 需要传入两个参数, 第一个是回调函数而第二个是延迟的毫秒数. 

```ks
set_timeout(||log("yes"), 2000);
log("end!");
```

上述例子中, 首先打印`end!`, 2秒后打印`yes`并退出程序. 

Key语言未提供事件循环系统, 取而代之的是等待数量. 在`timeout`开始之前, 该函数告诉Key编译器需要等待它结束, 而`timeout`完成后它告诉编译器不用等它了, 此时程序才真正退出. 

如你所见, 这样的函数很容易产生人尽皆知的"回调地狱", 不仅读起来十分丑陋, 维护起来也难以分辨参数和变量之间的关系. 

因此我们需要一个同步化的写法让程序员更轻松的维护各个异步行为, 控制异步的时机. 

## Planet

大部分语言为了区分异步和同步的存在差异, 特地设计了`await`运算符, 而为了兼容旧代码顺带产生了`async`函数. 但我认为, 我们需要的仅仅是将异步的行为同步化, 发挥异步的性能优势的同时得到同步的可读性, 无需特意区分`await`的存在. 因此我提供了`fall`方法用来直接阻塞主线程等待异步结果. 

`Planet`的结构: 使用`Planet::new`传入一个函数, 该函数带有一个参数(就叫它拨号员吧), 而拨号员拥有一个`ok`方法, 只要调用`ok`方法, 拨号员就会将传进`ok`的值传达给`Planet`本身. 此时`Planet`就需要一个地方来降落`fall`, 把处理好的值送给主线程. 举个例子:

```ks
// 将参数命名为我们的拨号员caller
let fallen = Planet::new(|caller|{
  // 将拨号员放进本来是异步的函数里, 调用ok方法
  set_timeout(||caller.ok("yes"), 2000)
  // 使用fall方法让主线程等着Planet降落
  // fall的返回值便是拨号员拿来的"yes"
}).fall();
// 打印yes
log(fallen);
// 行星降落后才打印出end
log("end");
```

## fall的时机

使用`Planet`并行处理两件事: 

```ks
// a2的延迟是2秒
let a2 = Planet::new(|caller|{
  set_timeout(||caller.ok("222"), 2000)
});
// a3是3秒
let a3 = Planet::new(|caller|{
  set_timeout(||caller.ok("333"), 3000)
});

log(a2.fall()); // 2秒后打印出222
log(a3.fall()); // 又隔了1秒打印333
```

该例子中, `Planet::new`的行为本身并不会阻塞程序运行, 因此程序一下子跑到了`log`前面. 于是`log`开始算`a2.fall()`的值, 但在算的过程因为是异步, 线程被阻塞住了, 便会等到`a2.fall()`的行为结束, 才会得到`222`并打印出来. 

于是走到`a3.fall()`这里, `a3`这颗行星在接到降落`fall`指令时发现拨号员还没传回来消息(此时才过2秒, `a3`设定了等3秒), 这颗`a3`行星便又等了1秒, 拨号员把`333`送了过来, 才降落到地面把`333`送给`log`. 

需要注意的是, `Planet`的值本身是不值得关注的, 因为它`fall`以后就不能`fall`第二次了, 在调用`fall`之前去读取`Planet`的值我想并无意义. 

此时, 我希望你能理解fall的时机对异步操作的影响. 我们如果想要`a2`降落完再开始进行`a3`要怎么做? 

```ks
let a2 = Planet::new(|caller|{
  set_timeout(||caller.ok("222"), 2000)
}).fall(); // 在这个fall调用时程序就开始等待了

log(a2); // 2秒后打印出222

let a3 = Planet::new(|caller|{
  set_timeout(||caller.ok("333"), 3000)
}); // 这里只是创建了行星本身, 任务开始

// 在这里fall的时候才是开始等待, 
// 但任务在创建行星时就开始运行了
log(a3.fall()); // 再隔了3秒才打印333
```

## Planet::all

由于`Planet`只提供`fall`去"我等你", 而不提供`then`这种"你等我"的设计, 因此Key语言并没有将`Planet`并发转换为单个`Planet`的方法. 但Key提供了一个`Planet::all`函数用来同时降落所有`planet`并返回其结果的列表. 

```ks
log(Planet::all(
  Planet::new(|caller|{
    set_timeout(||caller.ok("222"), 2000)
  }), // 不要在此处调用fall
  Planet::new(|caller|{
    set_timeout(||caller.ok("333"), 3000)
  })
)); // 3秒后打印[222, 333]
```
