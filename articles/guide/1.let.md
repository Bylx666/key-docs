# 声明变量

## 赋值皆复制

在入门`Key`语言之前, 你需要理解一个概念: `赋值皆复制`. 也就是说你的所有变量, 全部都是独一无二的. 

与之对应的, 很多编程语言中使用`引用`的概念, 不同变量使用同一个引用时, 相互修改就会相互影响. 但学习key语言则不需要担心这些. 

我们先试试`let`吧! 最简单的例子: 

```ks
// 定义变量a, 其值为20
let a = 20;
// 使用log函数, 将a打印出来
log(a);
```

什么是赋值皆复制? 我们先考虑一个类型叫作列表`List`, 它可以储存各种数量的值. 

列表使用`[]`的语法来定义, 在`[]`中用`,`分隔每个元素. 

```ks
// a是一个列表, 里面有3个元素
let a = [1,2,3];
// b也是一个列表, 内容和a一样
let b = a;
// 使用push方法在b的列表后增加一个元素
b.push(4);
// 此时a为[1,2,3], b为[1,2,3,4]
log(a, b);
```

如你所见, `b`的修改并不会影响到`a`. 

## 移动变量

如果我只是需要这个值, 拿走以后原来的值就不用了, 我怎么做? 如何用`移动`代替`复制`? 

回想刚才说的`List`, 它可以使用`[i]`的语法来获得第`n`个元素的内容. 其中`n`从`0`开始数, 也就是说第一个元素应该用`[0]`来获取, 第二个元素用`[1]`来获取. 

`[i]`的语法中, `i`叫作列表的索引`Index`. 

来试一下: 

```ks
let a = [1,2,3];
// 分别打印1 2
log(a[0], a[1]);
// a还是[1,2,3]
log(a);
```

我们需要用`let a < b`的语法来移动一个变量. 这样的话如果我们只是需要拿走一个值作为变量, 而不再需要原来的这个值的时, 就会清爽些(也会因为没有发生复制而省下来一些性能, 之后会说). 

```ks
let a = [1,2,3];
// 定义一个叫a0的变量, 
// 移动走a的第一个元素
let a0 < a[0];
// a1移动走第二个元素
let a1 < a[1];
// 此时a0为1, a1为2
log(a0, a1);
// 由于被移动走了2个元素
// 此时a就变成了[,,3]
log(a)
```

## 解构赋值

我们还可以使用解构`Destructuring`赋值, 语法为`let [a,b] = c`: 

```ks
let a = [1,2,3];
// 分别定义a0,a1,a2
// 为a的第1,2,3个元素
let [a0, a1, a2] = a;
// 1, 2, 3
log(a0, a1, a2);
// 此时a仍然是[1,2,3]
log(a);
```

使用解构移动赋值(解构赋值和`<`共同使用): 

```ks
let a = [1,2,3];
// 这里把'='改成'<'
let [a0, a1, a2] < a;
// 1, 2, 3
log(a0, a1, a2);
// 使用debug打印比log更详细的数据
// 此时a变成了空值uninit
// 因为a被整个移动并解构了
debug(a);
```

## 空值

如你所见, 上文使用`debug`打印`a`时出现了一个叫`uninit`的东西. 它就是我们Key语言中的`null`的存在. 

`uninit`的全称是`uninitialized`, 意为`未初始化`. 这个词义更适合脚本语言. 由于它在使用`log`打印时连空格都不打印, 纯粹的演绎了一个`空值`的形象, 因此在可能是`uninit`值的地方用`debug`函数来打印会更显眼. 

有3种方法定义空值`uninit`: 

```ks
// 用分号结束let语句
let a;
// '()'是uninit的简写
let a = ();
// uninit字面量
let a = uninit;
```

## 允许的变量名

变量名必须由英文字母, `~_@`这三个符号或数字组成. 

```ks
let a~_@88; // 可行
let never~gonna~give~U~up; // 可行
let 5aa6bb; // 不可行, 不能数字开头
```

有趣的是, unicode字符, 包括世界各语言的标点符号和emoji等均可做变量名. 

```ks
let 芙卡洛斯 = 1;
// 打印:1
log(芙卡洛斯);
```

## const

`let`的各种语法, `const`均可使用. 如果`let`得到的叫`变量`的话, `const`得到的我更愿意叫它`定量`而不是`常量`. 

和`let`的区别是, `const`定义的值的属性和索引均无法被赋值. 但仅此而已. 

```ks
const a = 0;
// 报错: a已被锁定
a = 2;
```

你还可以使用`const(变量名)`的语法来让一个变量不可被赋值. 

```ks
let a = 5;
// 使用const()语法
const(a);
// 错误:a已被锁定
a = 10;
```

`const`只是一个标记, 用来提醒用户这个变量不该被修改. 但实际上它的值是可以被移动的. 就连会修改它内部值的方法都可以正常调用. 

```ks
const a = 20;
// 可以正常移动
let b < a;
// a变成了uninit
debug(a);
```

正因为`const`值无法赋值, `const`被移动后变成`uninit`就不再能被赋新值了, 也就没意义了. 

你也可以用`let`同样的变量名去覆盖`const`值. 

```ks
// 声明一个a的定量
const a = 5;
// 声明一个变量a
// 值为定量a的值
let a < a;
// 虽然还是5, 但已经可以赋值了
log(a);
// 不报错
a = 10;
```

## 分号

Key语言不要求句末加`;`, 但`;`是区分语义的重要符号, 本身的含义是**空语句**. 举个例子:

```ks
// 创建了一个空列表
// 后面忘加分号了
let a = []
// 第二行也写了一个列表开头
[2]
```

上文代码会被解析为:

```ks
// a成了一个列表的第三个值
let a = [][2];
```

因此养成加分号的习惯, 会少很多语义冲突. 

## 注释

Key语言中使用`//`和`/' '/`分别代表单行注释和多行注释. 

```ks
// 一行小注释

/'
  好多行注释
'/

/'
  一个多行注释
  只要你不写注释结尾
  就可以注释到文件结束
```

## 结语

接下来我将说明一些基本类型的定义和使用. 

下一篇: <jmp to="guide/2.num/">数字的使用</jmp>
