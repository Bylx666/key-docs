# Key语言哲学

别担心, 这不是你想的那种头皮发麻的哲学. 我只是简单说一下Key语言最重要的理论和架构. 它们真的非常简单. 

## 赋值皆复制 & 生命周期

别被名字吓到了, 我们直接看一段代码:

```ks
let a = "结城理";
let b = a;
a += "牢月";
log(a,b);
// 结城理牢月 结城理
```

如你所见, Key语言在生命周期方面舍弃了引用`Reference`的存在, 也就是说Key可能会是比python还好学的语言. 

这样做有一些好处: 
1. 在一个作用域结束时就能直接删除`Deallocate`所有变量, 我们不再需要GC(垃圾回收系统, 往往需要独立一个线程在后台进行持久性工作). 
2. 不再需要区分浅克隆和深克隆, 实用性大幅提升.
3. 不用再担心你修改的值是否影响别的地方, 无需再显式复制. 
4. 不会像js那样产生`[]===[]`得到`false`的诡异行为

别急, 如果你学过C, 肯定想说性能和函数的事情. 事情当然没这么简单.

## 复制的性能

初学者注意, 以下讲的相对底层的东西你不需要掌握(对Key语言本身学习完全没影响). 我只希望下一次再见到这些底层非常常见的词汇时心中能多一丝印象. 

Rust底层使用操作系统和汇编实现的`memcpy`和`memmove`函数进行简单的内存复制, 本身的实现和优化就很现代. 

另外, Key语言提供了`take`和`swap`函数. 如果你不想要复制, 而是直接把这个数据转移给别的变量的话, 就试试它们吧. 这两个函数只是简单的在栈上活动, 并没有内存复制(严格意义上栈上复制不也是复制么:笑)的开销. 

试试`take`和`swap`:

```ks
let result;

fetch_something(|_res|{
  // 此行为直接复制一份_res
  result = _res;
})

fetch_something(|_res|{
  // 此行为把_res的内容的所有权直接转移给result, 此时_res是uninit
  result = take(_res);
})

fetch_something(|_res|{
  // 交换这两个变量, 此时result会拿到_res的数据
  // 而_res就会掌握result原本数据的所有权
  swap(_res, result);
})
```

初学者请看: 何为所有权? 简单说, 对于字符串, 你的变量本身持有的只是一个字符串的位置和长度这两个信息, 而字符串复制时会自动把 字符串位置处的内容 也复制一遍到其他位置, 然后新的变量拿到的是新的字符串的位置.

`take`和`swap`函数则是出于 已知这个字符串在`take`前后都只有一个变量持有, 因此就干脆不复制字符串了, 只把字符串的位置和长度交给另一个变量, 这样达到的"性能提升"的效果.

## 函数和方法

为什么`take`能无视复制规则进行转移? 是因为内置所以有特权么? 

其实是因为Key语言区分了Key模块`Key Module`和[原生模块](../native/readme.md)`Native Module`, 虽然Key语言内无法通过参数去改变传参者, 但原生模块的函数(由Rust编写)是可以直接获取其引用`Reference`的. 一是为了保护性能, 二是为了让原生能有对Key数据的更大操作空间. 

take和swap也只是原生函数之一, swap为例, 它只是通过两个变量的引用交换了一下它们而已. 

## outlive

无GC的脚本语言? 事实上Key语言的函数是可以离开定义的作用域的. 看个例子

```ks
let a = 5;
let f1() {
  let a = 20;
  :||:a // 相当于return (||return a)
}
log(f1()()) // 20
```

如果你是那种喜欢记概念的类型, 我想你心里是不是会立刻想到柯里化`currying`. 不过这和接下来要说的无关.

Key语言使用 我称之为`outlive`的算法, 虽然没啥论文支持, 但这其实就是个简单的引用计数系统. 

初学者注意: 以下只作为我对`outlive`算法的定义和参考, 对Key语言学习无影响. 

1. 作用域结构需要定义一个原子数字, 将其定义为`outlive`属性, 在我的Rust实现中使用了`AtomicUsize`
2. 你在作用域中创建函数时, 会为此作用域和此作用域以上的所有作用域的`outlive`的数值`+1`.
3. 当函数被复制时(赋值行为等), 为此函数的定义处作用域和定义处作用域以上的所有作用域的`outlive`的数值`+1`. 我的Rust实现为`impl Clone for Function {..clone(&self).. { self.increase_outlive_count() }}`. 函数复制到哪了暂时不需要管. 
4. 当函数丢失时(持有函数的变量被修改成了其他值等), 为此函数定义处作用域和定义处作用域以上的所有作用域`outlive`的数值`-1`. 遍历`-1`的过程中需要判断, 如果作用域已经结束了, 而且outlive被减为0, 就以函数回收的名义将该作用域回收掉. 我的实现是`impl Drop for Function {..drop(&mut self){ self.decrease_outlive_count() }}`
5. 作用域结束时, 对应`2.`, 将作用域所持有的所有函数(包括List, Instance, Obj内的)进行`outlive -1`操作, 和`4.`的行为一致. 之后将作用域的状态设置为已结束, 判断自己身上的outlive是否为0, 如果为0就将自己回收(以作用域正常结束的名义), 否则就不管自己, 等自己体内定义的函数被回收完自动回收自己.
6. `decrease_outlive_count`虽然只是遍历上层作用域把`outlive`值减一, 但由于在回收作用域本身时会额外调用一次`Drop`, 导致再一次运行函数的`decrease_outlive_count`, 因此你必须在该函数开头判断自己的`outlive`计数是否已经为0.

我的Rust的outlive实现在[`key-lang`](https://github.com/Bylx666/key-lang)仓库的`src/runtime/outlive.rs`. 

需要注意的是, 该算法虽然经历了我的大量测试, 但难免会有漏洞. 希望大家对于重复dealloc或者泄露问题积极提Issue. 

知道了`take`和`swap`, 我说说`const`. 

## const

你学过的`let`语法, 都可以直接套在`const`上. 另外, `const`支持`const( 变量名 )`的语法, 用来让一个变量变成常量. 

事实上, "常量"本身只是个锁定的**标记**, 用于提醒自己这是不该更改的值. 作为脚本语言, 强制在底层区分可变和不可变是很麻烦且几乎没有正面收益的设计. 

常量的本身, 属性和索引都无法被赋值(仅仅是定义在赋值行为上, 其实能够修改数据的方法还是可以继续调用的, 甚至`take`和`swap`都能对其生效). 

```ks
let a = { // 定义一个对象(和万物皆对象的对象不一样, 之后会讲)
  b: 2,
  c: 3
};
a.b = 9; // a == {b: 9, c: 3}
const(a);
a.c = 20; // 报错: 不可写入常量
```

想要可写, 可以使用`let`语句指向该常量:

```ks
let b = a;
b.c = 20; // 正常写入, a不受影响, b的属性被写入
```

当你想要转移常量数据的所有权时, 考虑`take`: 

```ks
let b = take(a);
b.c = 20;
a == uninit; // 虽然a已经是常量, 但take对其依然有效
```

## 结语

初学者来说这一篇读完你只需要记住赋值就是复制就好了, 传参数时 因为函数内会自动帮你 把参数名的变量(形参)定义成传的实际参数(实参), 这个过程也属于赋值, 所以也有复制的行为存在. 

值得注意的是, 复制函数的行为其实并没有多大开销, 只是复制了函数的指针, 所以不要对函数的复制有负罪感. 

总的来讲, Key语言通过最简单的方式实现了最好理解, 最方便, 原则上性能最好的架构, 希望我的努力能让你对编程这件事本身有所改观. 

Key语言虽然不是强类型(脚本语言本身就没法做成强类型), 但原生支持相对高性能的class对于一个脚本语言来说绝对是雪中送炭. 下一篇我会说明Key语言的类如何定义.
