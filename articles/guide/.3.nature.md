# Key语言哲学

别担心, 这不是你想的那种头皮发麻的哲学. 我只是简单说一下Key语言最重要的理论和架构. 它们真的非常简单. 

## 赋值皆复制 & 生命周期

别被名字吓到了, 我们直接看一段代码:

```ks
let a = "结城理";
let b = a;
a += "牢月";
log(a,b);
// 结城理牢月 结城理
```

如你所见, Key语言在生命周期方面舍弃了引用`Reference`的存在, 也就是说Key可能会是比python还好学的语言. 

这样做有一些好处: 
1. 在一个作用域结束时就能直接删除`Deallocate`所有变量, 我们不再需要GC(垃圾回收系统, 往往需要独立一个线程在后台进行持久性工作). 
2. 不再需要区分浅克隆和深克隆, 实用性大幅提升.
3. 不用再担心你修改的值是否影响别的地方, 无需再显式复制. 
4. 不会像js那样产生`[]===[]`得到`false`的诡异行为

别急, 如果你学过C, 肯定想说性能和函数的事情. 事情当然没这么简单.

## 复制的性能

初学者注意, 以下讲的相对底层的东西你不需要掌握(对Key语言本身学习完全没影响). 我只希望下一次再见到这些底层非常常见的词汇时心中能多一丝印象. 

Rust底层使用操作系统和汇编实现的`memcpy`和`memmove`函数进行简单的内存复制, 本身的实现和优化就很现代. 

另外, Key语言提供了`take`和`swap`函数. 如果你不想要复制, 而是直接把这个数据转移给别的变量的话, 就试试它们吧. 这两个函数只是简单的在栈上活动, 并没有内存复制(严格意义上栈上复制不也是复制么:笑)的开销. 

试试`take`和`swap`:

```ks
let result;

fetch_something(|_res|{
  // 此行为直接复制一份_res
  result = _res;
})

fetch_something(|_res|{
  // 此行为把_res的内容的所有权直接转移给result, 此时_res是uninit
  result = take(_res);
})

fetch_something(|_res|{
  // 交换这两个变量, 此时result会拿到_res的数据
  // 而_res就会掌握result原本数据的所有权
  swap(_res, result);
})
```

初学者请看: 何为所有权? 简单说, 对于字符串, 你的变量本身持有的只是一个字符串的位置和长度这两个信息, 而字符串复制时会自动把 字符串位置处的内容 也复制一遍到其他位置, 然后新的变量拿到的是新的字符串的位置.

`take`和`swap`函数则是出于 已知这个字符串在`take`前后都只有一个变量持有, 因此就干脆不复制字符串了, 只把字符串的位置和长度交给另一个变量, 这样达到的"性能提升"的效果.

## 函数和方法

为什么`take`能无视复制规则进行转移? 是因为内置所以有特权么? 

其实是因为Key语言区分了Key模块`Key Module`和[原生模块](../native/readme.md)`Native Module`, 虽然Key语言内无法通过参数去改变传参者, 但原生模块的函数(由Rust编写)是可以直接获取其引用`Reference`的. 一是为了保护性能, 二是为了让原生能有对Key数据的更大操作空间. 

take和swap也只是原生函数之一, swap为例, 它只是通过两个变量的引用交换了一下它们而已. 

## outlive

无GC的脚本语言? 事实上Key语言的函数是可以离开定义的作用域的. 看个例子

```ks
let a = 5;
let f1() {
  let a = 20;
  :||:a // 相当于return (||return a)
}
log(f1()()) // 20
```

如果你是那种喜欢记概念的类型, 我想你心里是不是会立刻想到柯里化`currying`. 不过这和接下来要说的无关.

Key语言使用 我称之为`outlive`的算法, 虽然没啥论文支持, 但这其实就是个简单的引用计数系统. 

初学者注意: 以下只作为我对`outlive`算法的定义和参考, 对Key语言学习无影响. 


需要注意的是, 该算法虽然经历了我的大量测试, 但难免会有漏洞. 希望大家对于重复dealloc或者泄露问题积极提Issue. 

## 结语

初学者来说这一篇读完你只需要记住赋值就是复制就好了, 传参数时 因为函数内会自动帮你 把参数名的变量(形参)定义成传的实际参数(实参), 这个过程也属于赋值, 所以也有复制的行为存在. 

值得注意的是, 复制函数的行为其实并没有多大开销, 只是复制了函数的指针, 所以不要对函数的复制有负罪感. 

总的来讲, Key语言通过最简单的方式实现了最好理解, 最方便, 原则上性能最好的架构, 希望我的努力能让你对编程这件事本身有所改观. 

Key语言虽然不是强类型(脚本语言本身就没法做成强类型), 但原生支持相对高性能的class对于一个脚本语言来说绝对是雪中送炭. 下一篇我会说明Key语言的类如何定义.
