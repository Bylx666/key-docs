# 定义语法

在key中定义关键词只有两个: `let`和`const`. 对于变量, 我建议使用下划线+小写的标识符. 同时,`@`,`~`,`_`都是合法的标识符符号. `let some_times = ..;`这样的标识符是key语言和Rust语言都提倡的.

## 基本类型 A

### 数字

Key中有3中数字类型: Uint, Int, Float. 为什么分3种? 

1. Uint的长度是你操作系统指针的长度, 虽然目前只支持64位, 但它可以当作指针的容器. 听不懂这些并不影响你学习Key语言.
2. Int和Int进行除法时会直接得到Int类型(向0方向取整), 比js的除法舒服多了.
3. | & ^这种二进制操作符只允许Uint使用, 会直观很多
4. 肉眼可见的性能优势就不细说了.

别担心, 这三种类型一般情况下可以直接进行运算, int和float运算会自动得到float结果, uint和int运算会自动得到运算符左侧的类型的结果.

而且这三种数字都有三种属性可以调用, 分别是int,float,uint. 如果你想要你的函数只是接受一个数字, 不妨直接在函数体内直接获取数字的对应类型的属性. 我说的可能有些乱, 你可以看一下使用方法:

```
(1.1).uint == 1u
2.float == 2.0
30u.int == 30
```

值得注意的是, 以上等号只是在说明他们类型相同. 实际上`1.0==1`也返回true.

以下是数字的定义方法

```
let n = 0u; // uint
let n = -3i; // int
let n = 10; // 不带后缀默认int
let f = 2.5; // float
let f = 2.5f; // float
let f = 3f; // 相当于3.0, float
```

Int, Uint, Float都分别有parse的静态方法, 而且支持选择进制

比如:

```
Int::parse("-2F", 16) == -47
```

不过这里的字符串不是语法上的解析, 不要加f,i,u这种类型后缀.

### 函数

函数(Func)也用let定义

```
// 最常用的定义
let f(a:Str,b) {
  ...
}
// 定义空函数
let f(a,b);
// 定义直接返回的函数
let f(): "好短好喜欢";
```

需要注意的是, `:`是一个语句,是return的缩写.在任何地方你都可以使用`:`开头的语句直接返回,效果和return一样.

以下写法是正确的

```
let a() {
  if true:30 else:60
}
```

另外, Key的顶级作用域返回值时会直接返回为程序状态码:

```
// 顶级作用域
:20
// error: process didn't exit successfully: `...` (exit code: 20)
```

函数的字面量是`|参数|{内容}`. 以下写法等价

```
let a(): 20;
let a = ||: 20;
```

### iife

有的时候不想作用域污染, 你可以直接这样

```
let b;
{
  let a = 99;
  b = a;
}
```

或者用`iife`的写法

```
let b = ||{
  let a = 99;
  :a
}();
```

### 函数导出

如果你希望写一个ks模块, 先记住以下写法:

```
mod 文件路径> 模块名
```

比如我当前cd在一个test文件夹(`cwd`), 里面有一个`module.ks`(要导入的模块)和一个`main.ks`(我要运行的ks文件)

你需要使用`mod.`语句来导出函数, 使用`-.`表达式来读取模块中的函数.

```
// module.ks
const i = 90;
mod.func(): i;
// 也可以写成
mod.func = ||: i;
```

```
// main.ks
mod module.ks> my_mod;
let i_from_mod = my_mod-.func(); // 90
```

### 定义类型

函数定义时可以在参数后加上`:类型`, 在调用时动态检查传入类型是否一致:

```
let a = "";
let f(n:Uint);
f(a) // err: 参数类型不同
```

此处的类型只允许字符, 不允许`some_mod-:T`的写法. 不论定义了什么类型, uninit都可以成功通过, 因此你的代码可能仍需要判断参数是否为uninit. 

其实你还可以使用`=`来设定默认参数.

```
let f(a:Int = 2) {
  log(a)
}
f() // 2
```

当然, 不加类型也能用`=`. 

```
let f(a = "233") {
  log(a)
}
f() // 233
```

### 宏

Key语言有个别的脚本都没做过的功能, 就是改变函数作用域. 换句话说, 你的每个函数都可以当作一个宏来使用. 

使用`call_here`:

```
let a;
let b;
let initer;
{ // 模拟作用域变化
  let a = 99;
  let b = 32;
  let f() {
    a = 20;
    b = 10;
  }
  initer = f;
}

// 两种情况下的a,b值
initer(); // a == (), b == ();
initer.call_here(()) // 第一个参数代表函数内的self, 传个uninit就行
                     // a == 20, b == 10
```

改变作用域时如果函数带有默认参数, 由于函数的上下文变化, 默认参数的上下文也会跟着变化(如果你的默认参数写了变量之类的就会跟着变成现在的上下文的该变量)

函数中的参数如果设定了自定义类型, 到了新作用域也会跟随新作用域的同名类型(没有同名类型就报错啦)

其他方法请参见[`Func`方法](../primitives/func.md)

### Bool

Key语言使用`true`和`false`作为判断用的字面量. 你可以使用rev属性直接取反:

```
true.rev == !true == false
```

虽然没什么用, bool还有个then方法, 代表为true时运行函数体,并返回该函数的返回值. 

```
true.then(||:233) == 233;
false.then(||:233) == ();
```

`()`是uninit的意思, 接下来会说.

### uninit

Key语言中有一个null的存在, 但它叫作uninit, 意思是未初始化的. 它的意思在中文中比null更直观, 使用起来比null更方便.

uninit有两种声明方式

```
let a; // a == uninit
let a = (); // a == uninit
```

## 注释

key中使用两种注释方法

```
// 单行注释
/'
  多行
  注释
'/
```

多行注释可以省略结尾的`'/`,代表直接注释到文件结束

## 结语

下一篇会继续说Key语言中的剩下的基本类型的声明方式, 如果有点累了不如在此分界稍作休息.
