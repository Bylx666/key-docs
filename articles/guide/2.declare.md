# 基本类型

Key语言中还有字符串(`Str`), 列表(`List`), 数组(真的是数字的组合, 叫作`Buf`), 对象(就是个哈希表,叫`Obj`). 

本篇中有一些新定义的行为(其他脚本语言没有做过的事情), 希望初学者不要畏惧.

## `Str`

Key中字符串(`Str`)有两种声明方式:

1. Raw String

(我该叫它`质符串`么..)

使用双引号修饰的字符串所见即所得, 前提是你的代码编辑器必须使用`UTF-8`编码进行输入. 

```
log("-\n\s\`\
   233")
```

期望输出

```
-\n\s\`\
   233
```

这种输入方式非常好用, 最大的缺点就是不能包含双引号. 需要输入双引号时请使用第二种.

2. Escaper String

转义字符串, 使用反引号` `` `修饰. 在转义字符串中可以使用反斜杠对字符串进行转义.

```
`\删除换行符  \n换行符 \r回车 \t制表符 \\反斜杠 \0字节的0 \`反引号 \{左大括号`
```

```
let a = 5;
let b = `ab\
         c\r\n\\ \`{a*a}\0`
```

期待输出

```
abc
\ `25
```

你可以使用加号拼接字符串

```
let s = 6;
"a" + s + "c" == "a6c"
```

你也可以使用`push`方法修改字符串.

字符串有2个常用属性: `len`和`byte_len`. 前者读取时会遍历一遍字符串, 可以获得精确的unicode字符数量; 后者直接读取字符串的内存长度. 这些属性不可修改.

另外, 你也可以使用索引来获得字符串的第n个字符: `"原神启动"[1] == "神"`

## 列表

列表(`List`)是Key语言中的不定类型的储存类型.

列表使用方括号定义, 结尾可以有一个多余逗号, 但不可在任何槽位留空. 你或许需要用`()`代替空槽.

```
let a = [1,(),[233,"455"],]; // [1,uninit,[233,"455"]]
let a = List::from_iter(10); // [0,1,2,3,4,5,6,7,8,9]
```

列表最常用的方法是`push`和`remove`,详见[list api](../primitives/list.md). 

列表也可以使用索引: `[1,2][1] == 2`

列表有一个属性`len`, 只读, 可以获取其长度.

## 数组

数组(`Buf`)就是一片内存区域(`uint8_t[]`), 如果你确信它是一个正确的字符串, 可以使用`buf.as_utf8`直接转为`Str`.

数组的声明使用单引号, 支持16进制输入和注释. 大括号内的将被解析为对应的byte, 大括号外的将被直接作为`utf8`编码(你可以使用`log('中文')`直接去看一个中文的utf8编码哦)

```
let b = 'aacc{ / 使用大括号来换行和输入十六进制
}ddee{
  ff 00 33 dd / 大括号内注释只允许单行注释, 使用单斜杠开头
  22334455
}';
```

我为数组实现的方法超级多(肝痛), 有兴趣可以去读一读. 最重要的方法还是`read`, `read_float`和`write`.

数组的索引得到的都是`Uint`类型. 

## 对象

万物皆对象? nonono, Key语言的对象(`Obj`)就是个臭哈希表. 对象的定义和使用和js几乎一样.

```
let o = {}; // 空对象
let o = {
  a:20, b:"好家伙"
}; // 带元素的对象
let o = Obj::from_list([
  ["友人","A"],
  ["结城","理"],
  ["坂本","先生"]
]); //通过列表解析对象
```

读取`uninit`的任何属性并不会报错(直接返回`uninit`),所以不用怕`Obj`读空值,更不用考虑可选链这种东西.

也可以直接为`Obj`插入本没有的值

```
let o = {};
o.a = 20;
// o == {a:20}
```

想`remove`也很简单:

```
let o = {a:20,b}; // 不写`:`就代表uninit
o.remove("b");
// o == {a:20}
```

对象里有函数? 这样写:

```
let test() log("ok");
let o = {f:test};
(o.f)(); // ok
```

## 结语

以上就是Key语言中可以直接定义的所有基本类型. 下一章会说明Key语言的哲学和设计(不是那种很难懂的, 恰恰相反, 我实现了比你已知的大部分编程语言还精致的语言架构), 想必会决定你对这门语言的好感. 
