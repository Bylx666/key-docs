# 定义语法

在key中定义关键词只有两个: `let`和`const`. 对于变量, 我建议使用下划线+小写的标识符. 同时,`@`,`~`,`_`都是合法的标识符符号. `let some_times = ..;`这样的标识符是key语言和Rust语言都提倡的.

别忘了你可以使用`~`命名, 像是:`never~gonna~give~you-up`, 可读性还不错, 也可以把它当个前缀标识一种类型的变量. 

另外, unicode字符全部都是合法的标识符(包括各语言的标点符号). 比如`let 原神 = "启动"`是合法的, 你也可以`let 😩 = 9`.

以下将会开始说明各个基本类型的定义方式. 

## 数字

Key中有3中数字类型: `Uint`(正整数), `Int`(可以带负号的整数), `Float`(浮点数). 

为什么分3种? 
1. `Uint`的长度是你操作系统指针的长度, 它可以当作指针的容器. 听不懂这些并不影响你学习Key语言.
2. `Int`和`Int`进行除法时会直接得到`Int`类型(向0方向取整), 比js的除法舒服多了.
3. `| & ^`这种二进制操作符只允许`Uint`使用, 会直观很多
4. 肉眼可见的性能优势就不细说了.

别担心, 这三种类型一般情况下可以直接进行运算, `int`和`float`运算会自动得到`float`结果, `uint`和`int`运算会自动得到运算符左侧的类型的结果.

而且这三种数字都有三种属性可以调用, 分别是`int`,`float`,`uint`. 如果你想要你的函数只是接受一个数字, 不妨直接在函数体内直接获取数字的对应类型的属性. 我说的可能有些乱, 你可以看一下使用方法:

```ks
( 1.1 ).uint == 1u
2 .float == 2.0
30u .int == 30
```

值得注意的是, 以上等号只是在说明他们类型相同. 实际上`1.0==1`也返回true (`int`和`float`运算自动同化成`float`进行对比)

以下是数字的定义方法

```ks
let n = 0u; // uint
let n = -3i; // int
let n = 10; // 不带后缀默认int
let f = 2.5; // float
let f = 2.5f; // float
let f = 3f; // 相当于3.0, float
```

`Int`, `Uint`, `Float`都分别有`parse`的静态方法, 而且支持选择进制

比如:

```ks
Int::parse("-2F", 16) == -47
```

不过这里的字符串不是语法上的解析, 不要加f,i,u这种类型后缀.

另外, 我做了一个好玩的特性: Uint可以使用索引获取第n个bit是1还是0 (从右往左). `uint[n]`等价于`(uint & (1<<n)) != 0`, 比如`8u[3] == true`

## `Func`

函数(`Func`)也用`let`定义

```ks
// 最常用的定义
let f(a:Str,b) {
  ...
}
// 定义空函数(分号是必须的, 否则会把下一句解析成其函数体)
let f(a,b);
// 定义直接返回的函数
let f(): "好短好喜欢";
```

需要注意的是, `:`是一个语句,是`return`的缩写.在任何地方你都可以使用`:`开头的语句直接返回,效果和`return`一样.

以下写法是正确的

```ks
let a() {
  if true:30 else:60
}
```

另外, Key的顶级作用域返回值时会直接返回为程序状态码:

```ks
// 顶级作用域
:20
// error: process didn't exit successfully: `...` (exit code: 20)
```

函数的字面量是`|参数|内容`. 以下写法等价

```ks
let a(): 20;
let a = ||: 20;
```

另外, 函数调用允许留空参数:

```ks
let f(a,b,c,d,e) log(c);
f(,,2,,); // 打印: 2
```

## iife

有的时候不想作用域污染, 你可以直接这样

```ks
let b;
{
  let a = 99;
  b = a;
}
```

或者用`iife`的写法

```ks
let b = ||{
  let a = 99;
  :a
}();
```

## 参数类型

函数定义时可以在参数后加上`:类型`, 在调用时动态检查传入类型是否一致:

```ks
let a = "";
let f(n:Uint);
f(a) // err: 参数类型不同
```

此处的类型只允许字符, 不允许`some_mod-:T`的写法. 不论定义了什么类型, `uninit`都可以成功通过, 因此你的代码可能仍需要判断参数是否为`uninit`. 

其实你还可以使用`=`来设定默认参数.

```ks
let f(a:Int = 2) {
  log(a)
}
f() // 2
```

当然, 不加类型也能用`=`. 

```ks
let f(a = "233") {
  log(a)
}
f() // 233
```

## 宏

Key语言有个别的脚本都没做过的功能, 就是改变函数作用域. 换句话说, 你的每个函数都可以当作一个宏来使用. 

使用`call_here`:

```ks
let a;
let b;
let initer;
{ // 模拟作用域变化
  let a = 99;
  let b = 32;
  let f() {
    a = 20;
    b = 10;
  }
  initer = f;
}

// 两种情况下的最外层的a,b值
initer(); // a == (), b == ();
initer.call_here(()) // 第一个参数代表函数内的self, 传个uninit就行
                     // a == 20, b == 10
```

改变作用域时如果函数带有默认参数, 由于函数的上下文变化, 默认参数的上下文也会跟着变化(如果你的默认参数写了变量之类的就会跟着变成现在的上下文的该变量)

函数中的参数如果设定了自定义类型, 到了新作用域也会跟随新作用域的同名类型(没有同名类型就报错啦)

其他方法请参见[`Func`方法](../primitives/func.md)

## `Bool`

Key语言使用`true`和`false`作为判断用的字面量. 你可以使用`rev`属性直接取反:

```ks
true.rev == !true == false
```

虽然没什么用, `bool`还有个`then`方法, 代表为`true`时运行函数体,并返回该函数的返回值. 

```ks
true.then(||:233) == 233;
false.then(||:233) == ();
```

`()`是uninit的意思, 接下来会说.

## `uninit`

Key语言中有一个`null`的存在, 但它叫作`uninit`, 意思是未初始化的. 它的意思在中文中比`null`更直观, 使用起来比`null`更方便.

`uninit`有三种声明方式

```ks
let a; // a == uninit
let a = (); // a == uninit
let a = uninit;
```

## 注释

key中使用两种注释方法

```ks
// 单行注释
/'
  多行
  注释
'/
```

多行注释可以省略结尾的`'/`,代表直接注释到文件结束

## 结语

下一篇会继续说Key语言中的剩下的基本类型的声明方式, 如果有点累了不如在此分界稍作休息.
