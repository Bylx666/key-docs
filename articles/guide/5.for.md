# if

在考虑循环`for`前, 先了解一下如何控制程序的走向. 

你可以使用`if`语句来判断一件事情的`真假`, 并在`真`时运行其中的语句. 

`if`语句语法: `if 条件 语句`. 

很多时候如果觉得条件和语句黏在一起不好读的话, 有两种选择: 

1. `if (条件) 语句`
2. `if 条件 {语句}`

我们试一下`if`

```ks
let a = 5;
if a > 4 {
  // 成功打印
  log("a确实大于4")
}
```

我们还可以使用`if .. else ..`(如果..否则..)的语法来写入在条件为`假`时运行的语句: 

```ks
// ;是一个空语句
if false ;
// else紧接if
else 
  // 成功打印
  log("确实是否则");
```

上述代码读起来是不是有些摸不到头绪? 加个括号吧: 

```ks
if false {}
else {
  log("确实是否则")
}
```

# for

了解了`if`, 我们就考虑一下循环吧. 

## 死循环

使用`for! ..`创建一个死循环(只要不手动打断, 就死活停不下来). 

为了不让死循环真的死掉, 我们使用`break`(打破循环)语句来手动把它停下来. 

```ks
// 让我们从0开始
let i = 0;
for! {
  // 让循环在i>=5时停下来 
  if i>=5 break;
  // 让i的值增加1
  // i+=1相当于i=i+1
  i += 1;
  // 让i在+=1后打印出来
  log(i);
}
// 打印出1 2 3 4 5
```

是不是感觉有点麻烦? 我们还有一种循环: 

## 条件循环

条件循环使用`for(条件) ..`的语法, 每次循环前都会自动判断条件是否为`真`. 

只有条件为`真`时才会继续循环, 否则立刻停止循环. 

```ks
let i = 0;
// 我们不想在i>=5时
// 继续循环下去了
for(i<5) {
  i += 1;
  log(i);
}
// 打印1 2 3 4 5
```

比起上文的死循环, 条件循环才是老祖. 

`for!`其实就是`for(true)`的简写而已. 

## 迭代

迭代`Iterator`是一种把一个集合的所有内容读取一遍的行为. 

迭代是一种特殊的循环, 语法有二: 

```ks
// 将迭代过程的值赋给value
for value: iterator {..}
// 只遍历, 不取其值
for iterator {..}
```

虽然迭代器的语句可以不用大括号包裹, 但强烈不建议不用大括号的写法. 

先看看哪些基本类型可以迭代, 以及迭代能得到什么值: 

### 整数

正整数`Uint`和整数`Int`都可以被迭代. 

从`0`开始, 到`n-1`结束. 

```ks
for i: 5 {
  log(i);
}
// 打印0 1 2 3 4
```

行为很像条件循环: 

```ks
let i = 0;
for(i<5) {
  log(i);
  i+=1;
}
```

好在迭代器的过程变量不会污染到外面: 

```ks
for i:2 {}
// 报错:无法找到变量
log(i);
```

而且用迭代器的话你可以直接省略`i`的值: 

```ks
for 5 {
  log("+1");
}
// 打印五次+1
```

### 字符串

迭代字符串会得到每个字符, 也是`Str`: 

```ks
for char: "芙卡洛斯" {
  log(char);
}
// 打印: 芙 卡 洛 斯
```

你还可以用`List::from_iter`(通过`from`迭代器`iter`创建列表)静态方法将字符串拆成列表:

```ks
let s = "芙卡洛斯";
// 打印: [芙, 卡, 洛, 斯]
log(
  List::from_iter(s)
);
```

### 列表

迭代列表会得到每个列表的元素: 

```ks
let a = [3,5,3];
for element: a {
  log(element)
}
// 打印 3 5 3

// 此时a还是[3,5,3]
log(a);
```

想到列表就会想到移动吧, 没有`let <`要怎么把这些值移动到迭代变量里呢? 

`take`是最常用的函数之一, 意为`取走`, 它可以移动走一个值: 

```ks
let a = "666";
// 其实和let b < a一样
let b = take(a);
// uninit, Str("666")
debug(a, b);
```

如你所见, 被传入`take`的值会变成`uninit`, 而得到`take`的人会成为赢家. 

思考一下如何移动掉列表, 并将其元素迭代出来? 

```ks
let a = [3,5,3];
// 我们只需要用take包裹a
for elem: take(a) {
  log(elem)
}
// 打印 3 5 3

// 此时a变成了uninit
debug(a);
```

当你已知不用一个值时, 习惯性的将其`take`给别人, 或许会让你的数据变得干净统一不少. 

如果你有深学计算机的信心, 请阅读[为什么需要`take`](#为什么需要take). 

### 数组

迭代`Buf`会得到`Uint`类型的元素: 

```ks
for n: '芙卡洛斯' {
  log(n);
}
// 打印 芙卡洛斯 的utf8码
```

### 哈希表

迭代哈希表得到的是其键名`Str`. 

值得注意的是, 哈希表的无序性注定其迭代不会太常用. 

```ks
let o = {
  a: 2,
  b: 4
};

for key: o {
  // 使用哈希表的键名作为索引
  log(`键名为{key}, \
    值为{o[key]}`)
}
// 打印两次键名和值
```

## 流程控制

有三个符号能控制`for`流程: `break`, `continue`和`return`. 

我们下一章会说明函数的使用, 因此`return`就放在下一篇. 

使用`break`打破循环, 使用`continue`跳过此次循环: 

```ks
// 我们从0开始
let i = 0;
for! {
  // 让i>=5时直接退出循环
  if i >= 5 break;
  // 别忘了让i += 1
  i += 1;
  // 我们在i为3时跳过后面的语句
  if i==3 continue;
  log(i);
}
// 打印: 1 2 4 5
```

## 结语

了解了使用`if`和`for`控制流程的方法后, 我们就可以去自己写一些函数来对参数进行操作了. 

下一篇: <jmp to="/guide/6.func">函数</jmp>

## 参考

### 为什么需要`take`

赋值皆复制造成了一些性能问题, 很多没有必要的复制很可能造成`key`语言的性能瓶颈. 

最简单的例子是, `Str`虽然被key语言描述为`独一无二`的字符串, 且其修改不会影响其他变量. 

事实上你的变量持有的只是字符串在内存里的位置而已. 在复制发生时, 内存中的这个字符串会整个复制到另一个地方, 从而把复制后的位置交给你作为'第二个'字符串. 

如果是`take`的话, 我们已知`take`前后都只有一个人持有该字符串, 因此只要把第一个字符串的位置信息送给第二个人, 就不用再复制内存中的字符串了. 

换言之, `take`保证了在不必要的时候不去复制一个值, 既让变量变得清爽不少, 又能让用户意识到目前用到的所有复制行为都是必要的, 从而提升内存管理意识, 减少之后学系统语言的思路转变的难度. 

### 生命周期

迭代器本身**不应该活的比被迭代的值久**. 以下行为会招来灾厄: 

```ks
let iter;
{
  let a = "启动启动启动!";
  // 使用lines方法创建了a的迭代器
  iter = a.lines();

  // 作用域结束且没有outlive
  // 此时a已经被回收了
}

// 此时迭代器迭代的是无主的内存
for l:iter {
  log(l);
}
```

该代码有时能正常运行, 但事实上这是一个未定义行为, 还请小心. 

为迭代器增加`outlive`计数的实现还在日程. 
