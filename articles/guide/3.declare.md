## 定义类型 B

Key语言中还有字符串(Str), 列表(List), 数组(真的是数字的组合, 叫作Buf), 对象(就是个哈希表,叫Obj). 

本篇中有一些新定义的行为(其他脚本语言没有做过的事情), 希望初学者不要畏惧.

### 字符串

Key中字符串(Str)有两种声明方式:

1. Raw String

(我该叫它`质符串`么..)

使用双引号修饰的字符串所见即所得, 前提是你的代码编辑器必须使用UTF8编码进行输入. 

```
log("-\n\s\`\
   233")
```

期望输出

```
-\n\s\`\
   233
```

这种输入方式非常好用, 最大的缺点就是不能包含双引号. 需要输入双引号时请使用第二种.

2. Escaper String

转义字符串, 使用反引号` `` `修饰. 在转义字符串中可以使用反斜杠对字符串进行转义.

```
`\删除换行符  \n换行符 \r回车 \t制表符 \\反斜杠 \0字节的0 \`反引号 \{左大括号`
```

```
let a = 5;
let b = `ab\
         c\r\n\\ \`{a*a}\0`
```

期待输出

```
abc
\ `25
```

你可以使用加号拼接字符串

```
let s = 6;
"a" + s + "c" == "a6c"
```

你也可以使用push方法修改字符串.

字符串有2个常用属性: len和byte_len. 前者读取时会遍历一遍字符串, 可以获得精确的unicode字符数量; 后者直接读取字符串的内存长度. 这些属性不可修改.

## 列表

列表(List)是Key语言中的不定类型的储存类型.

列表使用方括号定义, 结尾可以有一个多余逗号, 但不可在任何槽位留空. 你或许需要用`()`代替空槽.

```
let a = [1,(),[233,"455"],]; // [1,uninit,[233,"455"]]
let a = List::from_iter(10); // [0,1,2,3,4,5,6,7,8,9]
```

列表最常用的方法是push和remove,详见[list api](../primitives/list.md). 

列表有一个属性'len', 只读, 可以获取其长度.

## 数组

数组(Buf)就是一片内存区域(`uint8_t[]`), 如果你确信它是一个正确的字符串, 可以使用buf.as_utf8直接转为Str.

数组的声明使用单引号, 支持16进制输入和注释. 大括号内的将被解析为对应的byte, 大括号外的将被直接作为utf8编码(你可以使用`log('中文')`直接去看一个中文的utf8编码哦)

```
let b = 'aacc{ / 使用大括号来换行和输入十六进制
}ddee{
  ff 00 33 dd / 大括号内注释只允许单行注释, 使用单斜杠开头
  22334455
}';
```

我为数组实现的方法超级多(肝痛), 有兴趣可以去读一读. 最重要的方法还是read, read_float和write.

## 对象

万物皆对象? nonono, Key语言的对象(Obj)就是个臭哈希表. 对象的定义和使用和js几乎一样.

```
let o = {}; // 空对象
let o = {
  a:20, b:"好家伙"
}; // 带元素的对象
let o = Obj::from_list([
  ["友人","A"],
  ["结城","理"],
  ["坂本","先生"]
]); //通过列表解析对象
```

读取uninit的任何属性并不会报错(直接返回uninit),所以不用怕Obj读空值,更不用考虑可选链这种东西.

也可以直接为Obj插入本没有的值

```
let o = {};
o.a = 20;
// o == {a:20}
```

想remove也很简单:

```
let o = {a:20,b}; // 不写`:`就代表uninit
o.remove("b");
// o == {a:20}
```

对象里有函数? 这样写:

```
let test() log("ok");
let o = {f:test};
(o.f)(); // ok
```

## 结语

以上就是Key语言中可以直接定义的所有基本类型. Key语言虽然不是强类型(脚本语言本身就没法做成强类型), 但原生支持相对高性能的class对于一个脚本语言来说绝对是雪中送炭. 下一篇我会说明Key语言的类如何定义.
