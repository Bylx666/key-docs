# 运算符

Key语言中内置了大部分语言的标配的运算符. 以下是运算符列表和优先级(越往上越高)

|运算符| 作用 |
| --- | --- |
|`-.`,`-:`|访问模块|
|`::`, `.a`, `.f()`|读取静态方法, 读取属性, 调用方法|
|`f()`, `l[n]`|调用函数, 读取索引|
|一元运算符`-`,`!`|取负数, 取反(可以为`Uint`取反,相当于C的`~`)|
|`*`, `%`, `/`|乘,取模,除|
|`+`, `-`|加减|
|`<<`, `>>`|`Uint`位移|
|`&`|`Uint`取`BitAnd`按位与|
|`^`|`Uint`取`BitXor`按位异或|
|`\|`|`Uint`取`BitOr`按位或|
|`==`, `!=`, `>`, `<`, `>=`, `<=`|比较运算符|
|`is`|判断一个值是否为一个类型(只返回`Bool`)|
|`&&`|逻辑与(只返回`Bool`)|
|`\|\|`|逻辑或(只返回`Bool`)|
|`=`, `+= - * / % & \| ^ << >>=`|赋值(无返回值)|
|`\|>`|管道操作符|

## 需要注意

1. Key语言的赋值运算符没有返回值, 使用连等是无效的!
2. 虽然位操作只允许`Uint`使用,但右值依然可以直接写`Int`:`8u>>3==1`
3. 一元运算符的优先级意思是: 如果有别的运算符优先级更高, 一元运算符就会等优先级更高的运算符算完, 再附在前面(`-2.sqrt()==-4`而不是`4`,因为`.sqrt()`调用方法的优先级比一元运算符高. 你可以用括号:`(-2).sqrt()==4`是正确的)
4. `&&`和`||`的使用: 除了`uninit`会自动转为`false`, 两侧必须都是`Bool`, 否则会报错. 这样做的好处是引导程序员把一个值实际该有的状态写清, 当然你也可以直接写成`some!=uninit`来判断是否未初始化.
5. 计算并赋值一定会先读取其值(即使会触发`.@index_get`之类的函数), 再写入原值

比较大小相关:
1. 对于`List`和`Instance`的比较, 遇到无法比较的类型时会提前返回`false`(`!=`返回`true`)
2. `Obj`底层是哈希表,由于其无序性,使用大于和小于时一律得到`false` (意思是`Obj`之间只有`==`和`!=`)
3. 对于`Instance`之间的比较, 如果两个实例不属于同一个`class`的话会直接返回`false`(`!=`返回`true`)

初学者该表格不需要特别记忆, 只要知道`=`优先级最低,乘除比加减优先级高就好了. 该优先级设计参考了Rust等现代语言, 学过别的编程语言往往对这些优先级都有一定的使用习惯. 不确定优先级时也大可直接用小括号括住, 不存在什么负面影响.

## 数据列表比较算法

`Buf`, `Str`, `Instance`, `List`都属于有序数据列表. 比较是否相同的算法如下

```rust
fn compare(left: &[u8], right: &[u8]) -> bool {
  // 首先将短的buffer长度作为比较对象
  let l = min(left.len(), right.len());
  // 逐位比较，只要出现一位比较另一位为false就代表比较失败返回false
  for i in 0..l {
    if !(left[i] == right[i]) {
      return false
    }
  }
  // 若每一位都相同就比较长度，长度也相同则代表两个buffer全等
  return left.len() == right.len();
}
```

将`u8`替换为Key语言中的值, 结论是一样的.

比较大小算法:设两量为`a`和`b`

1. 比较长度, 长者大, 否则下一步(此时`a`,`b`应长度相同)
2. 逐位判断: 如果无法比较直接返回`false`(`!=`返回`true`), 只要出现大于直接返回大于,出现小于直接返回小于
3. 全部元素判断完成, 仍未出现大于小于或无法比较, 则是相等

## 管道操作符

Key语言中使用`|>`符号来解决各种丑陋的嵌套问题. 

使用`|%|`来代入管道前的表达式. 

```
let arg = "一个参数";
let f(s) {
  :"一个" + s // 在传入字符串前加`一个`
}
let a = arg
  |> f( |%| ) // 把arg代入到参数里
  |> f( |%| ) // 把f(arg)的结果再次代入f
log(a) // 一个一个一个参数
```

需要注意的是, `|>`左右都不可为空, 但`|>`右侧不是必须使用`|%|`来代入表达式. 

你甚至可以先存一发表达式, 在其他地方代入:

```
a+b |> () // ()是uninit, 意思是不做任何事情
         // 此时|%|中储存了`a+b`的表达式
{
  let a = 2;
  let b = 4;
  log( |%| ) // 代入到这么远的地方, 可以得到6
}
```

## 结语

这一篇是不是读着很有一种一边进一边出的感觉? 对于没有太多编程经验的人, 一次性不可能记住这么多运算符; 对编程老手来说这些又都司空见惯. 

没关系, 文档就是用来参考的, 这一篇能为你脑海留下各种运算符的丝刻印象就已经足够了. 

下一章会说明Key语言的流程控制语句`if`和`for`

## 附录

Rust中实现Key语言中使用的运算符优先级

```rust
pub const fn prec(x:&[u8])-> u8 {
  match x {
    b"-."|b"-:" => 16,
    b"::"|b"." => 15,
    b"("|b"[" => 14, // 代指调用和索引
    // unary => 13
    b"*" | b"%" | b"/" => 12, 
    b"+" | b"-" => 11, 
    b"<<"|b">>" => 10,
    b"&" => 9,
    b"^" => 8,
    b"|" => 7,
    b"=="|b"!="|b"<"|b">"|b"<="|b">=" => 6,
    b"is"=> 5,
    b"&&" => 4,
    b"||" => 3,
    b"="|b"+="|b"-="|b"*="|b"/="|b"%="|b"&="|b"|="|b"^="|b"<<="|b">>=" => 2,
    b"|>" => 1, // 管道运算符应当最靠后计算
    _=> 0
  }
}
```