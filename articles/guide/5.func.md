# 函数`Func`
# func

管道操作符写这里

列表遍历也写这里
`Func`可以直接用`let f(参数名) 函数体`声明: 
(obj.f)()的问题也这里

参数名之间用`,`隔开, `,`可省略. 

```ks
let f(a, b) {
  ..
}
// 定义空函数(分号是必须的, 否则会把下一句解析成其函数体)
let f();
// 定义直接返回的函数
let f(): "好短好喜欢";
```

## 返回

需要注意的是, `:`是一个语句,是`return`的缩写.在任何语句的开头你都可以使用`:`开头的语句直接返回,效果和`return`一样.

以下写法是正确的

```ks
let a() {
  if true:30 else:60
}
```

另外, Key的顶级作用域返回值时会直接返回为程序状态码:

```ks
// 顶级作用域
:20
// error: process didn't exit successfully: `...` (exit code: 20)
```

## 字面量

函数的字面量是`|参数|内容`. 以下写法等价

```ks
let a(): 20;
let a = ||: 20;
```

另外, 函数调用允许留空参数:

```ks
let f(a,b,c,d,e) log(c);
f(,,2,,); // 打印: 2
```

## iife

有的时候不想作用域污染, 你可以直接这样

```ks
let b;
{
  let a = 99;
  b = a;
}
```

或者用`iife`的写法

```ks
let b = ||{
  let a = 99;
  :a
}();
```

## 参数类型

函数定义时可以在参数后加上`:类型`, 在调用时动态检查传入类型是否一致:

```ks
let a = "";
let f(n:Uint);
f(a) // err: 参数类型不同
```

此处的类型只允许字符, 不允许`some_mod-:T`的写法. 不论定义了什么类型, `uninit`都可以成功通过, 因此你的代码可能仍需要判断参数是否为`uninit`. 

其实你还可以使用`=`来设定默认参数.

```ks
let f(a:Int = 2) {
  log(a)
}
f() // 2
```

当然, 不加类型也能用`=`. 

```ks
let f(a = Uint::max()) {
  log(a)
}
f() // 18446744073709551615
```

## 自定义参数

想设计各种数目参数的函数? 还在考虑每个参数的命名? 建议你尝试一下自定义参数: 它可以把所有参数作为一个列表直接传进你的函数. 

自定义参数使用`let f([列表名])..`或`|[列表名]|..`来定义. 

```ks
let a([args]) {
  log(args)
}
a(2,4,6);
// 打印[2,4,6]
```

直接用字面量: 

```ks
(|[args]| log(args))(2,4,6);
// 打印[2,4,6]
```

## 宏-`call_here`

Key语言有个别的脚本都没做过的功能, 就是改变函数作用域. 换句话说, 你的每个函数都可以当作一个宏来使用. 

使用`call_here`:

```ks
let a;
let b;
let initer;
{ // 模拟作用域变化
  let a = 99;
  let b = 32;
  let f() {
    a = 20;
    b = 10;
  }
  initer = f;
}

// 两种情况下的最外层的a,b值
initer(); // a == (), b == ();
initer.call_here(()) // 第一个参数代表函数内的self, 传个uninit就行
                     // a == 20, b == 10
```

改变作用域时如果函数带有默认参数, 由于函数的上下文变化, 默认参数的上下文也会跟着变化(如果你的默认参数写了变量之类的就会跟着变成现在的上下文的该变量)

函数中的参数如果设定了自定义类型, 到了新作用域也会跟随新作用域的同名类型(没有同名类型就报错啦)

## 宏-`unzip`

你可以使用`unzip`方法直接将函数体解压到某处. 函数的参数将被完全忽略. 

试试使用`unzip`来初始化一个作用域. 这种对上下文初始化的行为叫作`prelude`. 

```ks
let inner() {
  class A{};
  let a = 20;
  let b = 40;
}

{
  inner.unzip();
  log(a, b, A::{});
  // 20 40 60
}
```

值得注意的是, `unzip`的函数中的`return`会成为`unzip`方法的返回值. 

`continue`和`break`不会中断`unzip`外的循环, 而是直接报错. 

其他方法请参见<jmp to="/prim/func">`Func`方法</jmp>