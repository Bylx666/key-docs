# 类型声明

Key语言中使用`class`关键字来定义类型.

`T`是你的类型名: 

```ks
class T {
  ..
}
```

## 属性

直接在大括号中写属性名即可定义属性. 属性名之间用`,`分隔(`,`可省略). 

使用`::`运算符创建一个类型的`实例`: 

```ks
// A类型有两个属性
class A {
  a, 
  b,
}
// 使用A::{..}创建一个实例
// 打印:A { a: 9, b: 20 }
log(A::{ a: 9, b: 20 });
```

你还可以省略属性值, 使其默认为`uninit`: 

```ks
class A { a b };
// A { a, b }
log(A::{});
```

也可以在属性后写类型用于动态类型检查

```ks
class A {
  a: Str
}
// 报错:要求a属性是Str, 
// 但传入了Int
A::{ a: 9 };
```

## 实例方法

`实例方法`就是一个值可以调用的方法. 比如一个列表的`[].push(..)`的写法就叫做`调用实例方法`. 

我们可以为自己定义的类定义实例方法. 

实例方法可以在`class`体内使用`.method() ..`定义: (方法如果只有一个语句则不允许省略结尾的`,`)

```ks
class A {
  // A有一个a属性
  a
  // A有一个f的实例方法
  // 打印实例的a属性
  .f() log(self.a), 
}
// 创建实例A, 并调用其f方法
// 打印20
A::{a:20}.f();
```

如你所见, 在定义实例方法时, 我们用到了`self`关键字. 

`self`代表实例目前的值. 可以通过`self`来修改和读取实例值. 

## 静态方法

静态方法虽然也可以定义到类型上, 但它的行为和一般函数并无实际区别. 

值得注意的是, 只有实例方法的`self`有意义. `self`对于其他任何地方包括`静态方法`都无实际意义. 

定义静态方法用`static() ..`, 而访问静态方法也使用`::`表达式, 但`::`右侧是静态方法的名称: 

```ks
class A {
  // A有两个属性
  a: Int, b: Str,
  // 定义一个静态方法new
  // 只有一行的语句, 结尾必须有逗号
  new(): A::{ a: 2, b: "yes" }, 
  // 定义一个实例方法get
  // 用来获取自己的a属性
  .get(): self.a
}
// 使用A::new调用A的new静态方法
let a = A::new();
// 打印 A { a: 2 , b: yes }
log(a);
// 打印 2
log(a.get());
```

## 解构

自定义类型均可解构. 

使用`let {}`解构一个自定义类型: 

```ks
class A {
  a b
}
// 构造一个A的实例
let right = A::{
  a: 20, b: 90
};
// 使用移动解构赋值
let {a, b} < right;
// 打印: 20 90
log(a, b);
// right被移动, 变为uninit
debug(right);
```

## 类型检查

自定义的类型也可以作为类型检查对象. 

```ks
class A {}
// 要求参数必须是A类型
let must_A(a: A);
// 用A类型传参, 正常
must_A(A::{});
// 用Str, 报错
must_A("no");
```

使用`is`:

```ks
class A {}
// A的实例当然是A类型!
log(A::{} is A);
```

## 结语

对于结构明确的数据, 自定义`class`远比`Obj`用着方便. 

此外, 你还可以使用模块`Module`. 

下一篇: <jmp to="/guide/8.mod">模块化</jmp>

## 参考

本地类`Local Class`的实现是很简约的, 同时很多不会很常用的行为被列举如下, 如果对本地类的具体行为有理解需求可以试着翻阅一下. 

### 类的底层设计

Key中的类型和万物皆对象的语言的类型不同, 

1. Key不使用继承链的设计, 而是直接允许你在一个类内部写入另一个类来达到类似继承的效果.
2. Key中的类的实例`Instance`的属性不允许扩展或删除(换句话说,实例和对象完全是两码事, 对象其实反而是后到者)
3. 不论对象`Obj`还是实例`Instance`, 属性和方法都是分离的. 简单讲就是, `a.method()`是描述方法的调用, `(a.method)()`是描述使其属性作为函数的调用.

这样的实现有非常多优点:

1. 实例底层只是定长的储存Key语言值的array, 如果叫Key的字面量为`Litr`的话, 在C的伪代码中的表示就是`Litr[class_declare.properties.length]`. 在读取属性时, 属性名会直接映射为array的索引, 比起哈希表形态储存的`对象`性能有着颠覆性的差距. 
2. 你完全可以在实例中放入自己的类型(我是`class A`, 那么`A`的属性同样允许储存`A`类型本身, 而不会导致class变成无限大小). 原理是底层`Litr[]`存放的只是实例指针, 而指针大小永远都不会变. 
3. 属性不允许扩展和删除就代表你永远可以安心读取实例的对应属性, 不存在属性被误删导致难以排查的问题. 
4. 区别实例和对象, 有利于属性方法区分这一功能的实现. 换句话说, 创建新实例时不会在新实例上自动挂个方法表, 而是在调用方法时会直接查自己类型的方法进行调用. 这或许也是清爽设计的体现. 

### 类型实例方法不会梦到`::`静态访问

值得注意的是, 实例方法也能通过`::`访问(和静态方法的命名不冲突, 静态方法优先), 此时你可以使用函数的`call`方法为此次调用绑定`self`(该绑定也会给予函数对这个值的写入权力). 如果不绑定`self`, 该函数就可能读写这个模块的`self`.

```ks
class A {
  a,
  .get(): self.a
}
let test_obj = {a:233};
log(A::get.call(test_obj)) // 233
```

### 直男`self`

需要注意的是, `self = ..`的写法是有效的. 换句话说, `self = ..`的语法有可能直接改变self类型, 导致后续代码无法正常运行, 请避免此写法. 

方法外的self目前只是代表最顶层作用域的一个变量, 用户可以自由使用. 作为关键词, `self`不会被let覆盖, 也就是说一个模块中任何没有绑定self的地方都能直接访问到该值, 有点用的使用方法是:

```ks
self = {};
// ...
{
  self.some_prop = 20;
  self.any_prop = 30;
  // ...
}
```

不过`self`如果你不管它,它就只是个`uninit`. 

`self`只有在实例方法和<jmp to="/prim/func#call">`call`</jmp>手动绑定这两种情况会改变. 不像js, Key语言中的`self`和`Obj`完全没有关系. 

### 自定义迭代器

你可以通过定义`.@next`方法为你的类型实现迭代器. 

```ks
let a = '{ab bc cd de}';
class A {
  i:Int,
  .@next() {
    // 如果i大于a的长度则直接返回迭代结束的标志
    if self.i>=a.len: Sym::iter_end();
    let n = a[self.i];
    self.i += 1;
    :n
  }
}

for n: A::{i:0} {
  log(n)
}
```

Key语言中有一个特别的类型: `Sym`, 代表`Symbol`, 就是标志的意思.

目前`Sym`只有一个使用方法: 作为`@next`方法的结束标志. 通过调用`Sym::iter_end()`可以得到一个迭代结束的标志.

### 自定义索引

class可以定义`.@index_get`和`.@index_set`实例方法来捕获索引的使用(在一开始我说过的, `@`也是合法的标识符, 尽情使用)

```ks
class MyVec {
  a:Buf
  .@index_get(i): self.a[i].pow(2), // 别忘了逗号, 此处在读取数值时得到的是其平方
  .@index_set(i, v) {
    self.a[i] = v;
  }
}
let a = MyVec::{a:'233'};
a[2] = 3; // 调用index_set
log(a); // MyVec { a: Buf[32, 33, 9]  }
log(a[2]) // 调用index_get得到9
```

需要注意的是, `@index_set`虽然是方法, 但如果数据是常量也会被阻止使用. 

```ks
const a = MyVec::{a:'成常量了?'};
a[1] = 9; // 报错: 无法写入常量
```

### 自定义析构函数

你甚至可以在脚本语言里使用析构函数. (初学者无需掌握)

为你的类定义`.@clone`和`.@drop`来调用复制和析构函数. 由于脚本语言直接操作内存和指针是非常不安全的行为, 原则上这两个函数的实用性或许只来源于对原生模块函数的转接. 

```ks
let a = 0
class Rc {
  .@clone() {
    a+=1;
    :Rc::{} // 都说是复制了, 你总得返回一个同类型的值
  },
  .@drop() a-=1
}
```