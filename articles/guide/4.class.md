# 类型声明

## 类的底层设计

Key语言中使用`class`关键字来定义类型. Key中的类型和万物皆对象的语言的类型不同, 

1. Key不使用继承链的设计, 而是直接允许你在一个类内部写入另一个类来达到类似继承的效果.
2. Key中的类的实例`Instance`的属性不允许扩展或删除(换句话说,实例和对象完全是两码事, 对象其实反而是后到者)
3. 不论对象`Obj`还是实例`Instance`, 属性和方法都是分离的. 简单讲就是, `a.method()`是描述方法的调用, `(a.method)()`是描述使其属性作为函数的调用.

这样的实现有非常多优点:

1. 实例底层只是定长的储存Key语言值的array, 如果叫Key的字面量为`Litr`的话, 在C的伪代码中的表示就是`Litr[class_declare-> properties-> length]` (该原理和Key学习无关, 无需为此专门翻阅C资料). 在读取属性时, 属性名会直接映射为array的索引, 比起哈希形态储存的`Obj`性能有着颠覆性的差距.
2. 你完全可以在实例中放入自己的类型(我是`class A`, 那么`A`的属性同样允许储存`A`类型本身, 而不会导致class变成无限大小). 原理是底层`Litr[]`存放的只是实例指针, 而指针大小永远都不会变(不懂指针也没关系, 大概记一下有指针这东西的存在就好).
3. 属性不允许扩展和删除就代表你永远可以安心读取实例的对应属性, 不存在属性被误删导致难以排查的问题. 
4. 区别实例和对象, 有利于属性方法区分这一功能的实现. 换句话说, 创建新实例时不会在新实例上自动挂个方法表, 而是在调用方法时会直接查自己类型的方法进行调用. 这或许也是清爽设计的体现.

## 属性

直接在大括号中写属性名, 用逗号分隔(逗号可省略), 也可以在属性后写类型用于动态类型检查

```ks
class A {
  a:Str, 
  b,
}
```

## 方法

定义方法使用`.method() 函数体`语法

方法和静态方法后的逗号尽量别省略, 因为有可能上一个方法是单句, 和下一个方法的`.xx()`解析到一起导致语法错误. 

```ks
class A {
  a b
  .t();, // 空语句
  .u(): self.a, // 返回a属性的值
  .v(): take(self.b), // 把b属性的值移出
}
```

方法中可以使用self关键字, 代表实例目前的值. 可以通过self来修改和读取实例值. 

## self

需要注意的是, `self = ..`的写法是有效的. 换句话说, `self = ..`的语法有可能直接改变self类型, 导致后续代码无法正常运行, 请避免此写法. 

方法外的self目前只是代表最顶层作用域的一个变量, 用户可以自由使用. 作为关键词, `self`不会被let覆盖, 也就是说一个模块中任何没有绑定self的地方都能直接访问到该值, 有点用的使用方法是:

```ks
self = {};
// ...
{
  self.some_prop = 20;
  self.any_prop = 30;
  // ...
}
```

不过self如果你不管它,它就只是个uninit. 

self只有在实例方法和call手动绑定这两种情况会改变. 不像js, Key中的self和Obj完全没有关系. 

## 静态方法

静态方法就是一个普通函数, 但需要通过类调用. 静态方法和其他普通函数的self无意义.

定义静态方法用`static() 函数体`:

```ks
class A {
  a:Int,b:Str,
  new(): A::{a:2,b:"yes"}, // 此处如果没有逗号, 下一句定义方法时的`.`就会和这里连在一起, 导致语法错误
  .get(): take(self.a)
}
```

访问静态方法使用`::`表达式:

```ks
let a = A::new(); // A {a:2,b:yes}
log(a.get()) // 2
```

如你所见, 在Key语言中没有new关键词, 而是通过`类型名::{}`的语法来声明一个新实例. 需要注意的是, 在**模块内**这样声明实例可以省略各个参数, 用uninit缺省:

```ks
class A {
  a,b,c
}
A::{} // 不会报错, 此时a,b,c都是uninit
```

之所以需要`A::{}`而不是`A {}`是因为Key语言并不强制分号, 第一行末尾是变量且第二行开头是`{`就会直接被解析成对象也是很不合理的. 

值得注意的是, 实例方法也能通过`::`访问(和静态方法的命名不冲突, 静态方法优先), 此时你可以使用函数的`call`方法为此次调用绑定`self`(该绑定也会给予函数对这个值的写入权力). 如果不绑定`self`, 该函数就可能读写这个模块的`self`.

```ks
let test_obj = {a:233};
log(A::get.call(test_obj)) // 233
```

通过`::`访问实例方法的行为仅限本地类型, 原生类型和基本类型不可用. 

## is

Key语言使用`is`运算符来判断类型. 

```ks
// module.ks
mod:A{} // 声明一个A类型
mod.a(): A::{}; // 导出一个能创建A实例的函数
```

```ks
// main.ks
mod module.ks> m;
let a = m-.a();
log(a is m-:A); // ture
```

对基本类型也有效: `"233" is Str == true`

## 索引

class可以定义`.@index_get`和`.@index_set`实例方法来捕获索引的使用(在一开始我说过的, `@`也是合法的标识符, 尽情使用)

```ks
class MyVec {
  a:Buf
  .@index_get(i): self.a[i].sqrt(), // 别忘了逗号, 此处在读取数值时得到的是其平方
  .@index_set(i, v) {
    self.a[i] = v;
  }
}
let a = MyVec::{a:'233'};
a[2] = 3; // 调用index_set
log(a); // MyVec { a: Buf[32, 33, 9]  }
log(a[2]) // 调用index_get得到9
```

需要注意的是, `@index_set`虽然是方法, 但如果数据是常量也会被阻止使用. 

```ks
const a = MyVec::{a:'成常量了?'};
a[1] = 9; // 报错: 无法写入常量
```

## 析构函数

你甚至可以在脚本语言里使用析构函数. (初学者无需掌握)

为你的类定义`.@clone`和`.@drop`来调用复制和析构函数. 由于脚本语言直接操作内存和指针是非常不安全的行为, 原则上这两个函数的实用性或许只来源于对原生模块函数的转接. 

```ks
let a = 0
class Rc {
  .@clone() {
    a+=1;
    :Rc::{} // 都说是复制了, 你总得返回一个同类型的值
  },
  .@drop() a-=1
}
```

## 结语

原生支持类型声明就是舒服对吧. 不仅如此, Key语言还支持模块化. 

下一章将会说明模块的使用.
