# class

## 类的底层设计

Key语言中使用`class`关键字来定义类型. Key中的类型和万物皆对象的语言的类型不同, 

1. Key不使用继承链的设计, 而是直接允许你在一个类内部写入另一个类来达到类似继承的效果.
2. Key中的类的实例`Instance`的属性不允许扩展或删除(换句话说,实例和对象完全是两码事, 对象其实反而是后到者)
3. 不论对象`Obj`还是实例`Instance`, 属性和方法都是分离的. 简单讲就是, `a.method()`是描述方法的调用, `(a.method)()`是描述使其属性作为函数的调用.

这样的实现有非常多优点:

1. 实例底层只是定长的储存Key语言值的array, 如果叫Key的字面量为`Litr`的话, 在C的伪代码中的表示就是`Litr[class_declare-> properties-> length]` (该原理和Key学习无关, 无需为此专门翻阅C资料). 在读取属性时, 属性名会直接映射为array的索引, 比起哈希形态储存的`Obj`性能有着颠覆性的差距.
2. 你完全可以在实例中放入自己的类型(我是`class A`, 那么`A`的属性同样允许储存`A`类型本身, 而不会导致class变成无限大小). 原理是底层`Litr[]`存放的只是实例指针, 而指针大小永远都不会变(不懂指针也没关系, 大概记一下有指针这东西的存在就好).
3. 属性不允许扩展和删除就代表你永远可以安心读取实例的对应属性, 不存在属性被误删导致难以排查的问题. 
4. 区别实例和对象, 有利于属性方法区分这一功能的实现. 换句话说, 创建新实例时不会在新实例上自动挂个方法表, 而是在调用方法时会直接查自己类型的方法进行调用. 这或许也是清爽设计的体现.

## 属性

直接在大括号中写属性名, 用逗号分隔(逗号可省略), 也可以在属性后写类型用于动态类型检查

```
class A {
  a:Str, 
  b,
}
```

## 方法

定义方法使用`.method() 函数体`语法

方法和静态方法后的逗号尽量别省略, 因为有可能上一个方法是单句, 和下一个方法的`.xx()`解析到一起导致语法错误. 

```
class A {
  a b
  .t();, // 空语句
  .u(): self.a, // 返回a属性的值
  .v(): take(self.b), // 把b属性的值移出
}
```

方法中可以使用self关键字, 代表实例目前的值. 可以通过self来修改和读取实例值. 

## 静态方法

静态方法就是一个普通函数, 但需要通过类调用. 静态方法和其他普通函数的self无意义.

定义静态方法用`static() 函数体`:

```
class A {
  a:Int,b:Str,
  new(): A::{a:2,b:"yes"}, // 此处如果没有逗号, 下一句定义方法时的`.`就会和这里连在一起, 导致语法错误
  .get(): take(self.a)
}
```

访问静态方法使用`::`表达式:

```
let a = A::new(); // A {a:2,b:yes}
log(a.get()) // 2
```

值得注意的是, 实例方法也能通过`::`访问(和静态方法的命名不冲突, 静态方法优先), 此时你可以使用函数的`call`方法为此次调用绑定`self`(该绑定也会给予函数对这个值的写入权力). 如果不绑定`self`, 该函数就可能读写这个模块的`self`(见下文self章节).

```
let test_obj = {a:233};
log(A::get.call(test_obj)) // 233
```

如你所见, 在Key语言中没有new关键词, 而是通过`类型名::{}`的语法来声明一个新实例. 需要注意的是, 在**模块内**这样声明实例可以省略各个参数, 用uninit缺省:

```
class A {
  a,b,c
}
A::{} // 不会报错, 此时a,b,c都是uninit
```

## 模块化

Key语言使用`mod`关键词导出和导入class. 使用`mod:`语句导出类(对应函数`mod.`), 使用`-:`表达式使用模块中的类(对应函数的`-.`)

假设我的cwd中有一个`module.ks`(作模块)和一个`main.ks`(运行用):

```
// module.ks
mod:MyClass {
  >a, // 使用>前缀表示模块外可直接读写此值(public)
  >new(): MyClass::{a:3}, // public的静态方法
  >.test(): self.a.sqrt() // public的实例方法(取数字的平方)
}
```

```
// main.ks
mod module.ks> m; // 导入module.ks文件, 作为模块m
class T = m-:MyClass; // 将T作为m模块的MyClass的别名
let direct = T::{a:4}; // 直接构造该类型
let new = T::new(); // 通过静态方法构造
log(direct.test(), new.test())
```

各个部分的导出的实际意义: 
1. `mod:T`和`class T`的区别在于模块外能否使用该类型来类型检查, 以及能否调用其静态方法
2. `> prop`和`prop`的区别在于模块外能否对此属性直接进行读写, 模块外想创建一个此类型的实例必须保证`1.`的同时,所有值都是public`>`状态
3. `> .method()`和`.method()`的区别在于模块外能否调用该类型的实例的此方法(无关乎`1.`)
4. `> static()`和`static()`的区别是, 在`1.`满足public时, 模块外在持有该类型时能否调用此静态方法

不用去刻意记忆或区分这些概念, 作为初学者需要记忆的只是: 一个实例即使没有导出到模块外, 实例也可以调用自己类型的方法. 比如:

```
// module.ks
class A {
  a,b,
  >.yes() log("看来能行")
}
mod.create_a(): A::{}; // 全部缺省
```

```
// main.ks
mod module.ks> m;
m-.create_a().yes() // 打印: 看来能行
```

如果模块外想要构造模块内定义的类, 就必须保证所有的属性都是public:

```
// module.ks
mod: A {
  >a,>b
}
```

```
// main.ks
mod module.ks> m;
m-:A::{a:0,b:0} // 在模块外构造模块内定义的类型时不可省略任何属性
```

只要一个属性不是public, 模块外就因为无法访问该属性而无法构造该类型. 这个特点想必可以帮你减轻些模块内的属性值的判断压力. 

## self

需要注意的是, `self = ..`的写法是有效的. 换句话说, `self = ..`的语法有可能直接改变self类型, 导致后续代码无法正常运行, 请避免此写法. 

方法外的self目前只是代表最顶层作用域的一个变量, 用户可以自由使用. 作为关键词, `self`不会被let覆盖, 也就是说一个模块中任何没有绑定self的地方都能直接访问到该值, 有点用的使用方法是:

```
self = {};
// ...
{
  self.some_prop = 20;
  self.any_prop = 30;
  // ...
}
```

不过self如果你不管它,它就只是个uninit. 

self只有在实例方法和call手动绑定这两种情况会改变. 不像js, Key中的self和Obj完全没有关系. 
