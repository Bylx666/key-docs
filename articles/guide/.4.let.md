# let语法

在知道了`赋值皆赋值`和`take`以后, 就可以真正理解`let`的使用了. 

## 初始值

`let`+变量名后使用`=`或`()`为其设置初始值. 

```ks
// 声明变量a, 此时a的值为uninit
let a;

// 声明变量a, 并使a为Int 0
let a = 0;

// 声明函数a, 函数体为空语句";"
let a();

// 声明函数a, 函数体为空语句";", 
// 函数体后跟随";"标记let语句的结束
// 小括号可省略
let a = (||;);
```

## 夺取赋值

`let`+变量名后, 可以使用`<`代替`=`, 代表夺取(`take`)右侧值. 

```ks
// 声明一个right哈希表
let right = {a:99};

// 使用let <语法, 将右侧的值夺走
let get < right.a;

debug(get, right.a); // Int(99) Uninit
```

上述代码中, 

```ks
let get < right.a;
```

等价于

```ks
let get = take(right.a);
```

## 解构赋值

使用`let [a,b]`或`let {a,b}`的语法, 将右侧的值解构成单元素. 

解构括号中的逗号可省略. 

另外, 解构赋值也支持夺取赋值`<`. 

### 解构线性数据

列表`List`, 字符串`Str`和数组`Buf`这三种类型由于没有属性但有索引, 我们就叫它线性类型. 

线性数据建议使用中括号`[]`进行解构. 

事实上, 你大部分时候当然不知道右侧的值有多长. 别担心, 左侧变量数量如果多出来的话, 多出来的部分都会自动设定为`uninit`而不会直接抛出错误. 

```ks
// 解构列表
let [a b c] = [2 4 6 8];
log(a,b,c); // 2 4 6

// 解构字符串
let [a b c d e] = "芙卡洛斯"
log(a,b,c,d,e); // 芙 卡 洛 斯 uninit

// 解构Buf
let [a b c d] = 998u.as32();
log(a,b,c,d);
// 小字端cpu时打印: 230 3 0 0
```

### 解构属性

原生类实例, 本地类实例和哈希表`Obj`因为都有变化的属性, 所以建议使用大括号`{}`来解构它们. 

属性比起线性解构可就严格些了, 只要右侧的值中不存在左侧的属性名就会直接报错. 

```ks
// 解构哈希表
let {a b} = {a:20, b:40};
log(a,b);

// 右侧没有b属性
let {a b} = {a:9};
// 报错: 哈希表中没有'b'属性

// 定义一个有a和b两个属性的本地类型A
class A {
  a b
}

// 创建一个A的实例
let inst = A::{a:9, b:20};
// 解构A实例得到a和b
let {a b} = inst;
log(a,b); // 9 20
```

原生类实例被解构时, 会自动调用其属性的<jmp to="/native/3.class#属性">`getter`</jmp>获取属性值. 

### 解构夺取

解构赋值也可以正常使用夺取赋值`<`. 

```ks
// 定义一个有a和b两个属性的本地类型A
class A {
  a b
}

// 创建一个A的实例
let inst = A::{a:9, b:20};
// 夺取inst, 并将其属性赋给a,b
let {a b} < inst;

// a和b已经拿到了inst的属性
log(a,b); // 9 20
// 但inst早已长眠
log(inst); // uninit
```

另外, 值得注意的是, 解构括号`[]`和`{}`并无实际区别. 

以下写法是正确的:

```ks
let {a b c} = [2,4,6];
let [a b] = {a:2, b:4};
```

## const

你学过的`let`语法, 都可以直接套在`const`上. 另外, `const`支持`const( 变量名 )`的语法, 用来让一个变量变成常量. 

事实上, "常量"本身只是个锁定的**标记**, 用于提醒自己这是不该更改的值. 作为脚本语言, 强制在底层区分可变和不可变是很麻烦且几乎没有正面收益的设计. 

常量的本身, 属性和索引都无法被赋值(仅仅是定义在赋值行为上, 其实能够修改数据的方法还是可以继续调用的, 甚至`take`和`swap`都能对其生效). 

```ks
let a = { // 定义一个哈希表
  b: 2,
  c: 3
};
a.b = 9; // a == {b: 9, c: 3}
const(a);
a.c = 20; // 报错: 不可写入常量
```

想要可写, 可以使用`let`语句指向该常量:

```ks
let b = a;
b.c = 20; // 正常写入, a不受影响, b的属性被写入
```

当你想要转移常量数据的所有权时, 考虑`let <`或`take`: 

```ks
let b < a;
b.c = 20;
a == uninit; // 虽然a已经是常量, 但take对其依然有效
```